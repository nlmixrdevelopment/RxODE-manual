[["index.html", "RxODE user manual Chapter 1 Introduction", " RxODE user manual Matthew Fidler 2020-12-15 Chapter 1 Introduction Welcome to the RxODE user guide; RxODE is an R package for solving and simulating from ode-based models. These models are convert the RxODE mini-language to C and create a compiled dll for fast solving. ODE solving using RxODE has a few key parts: RxODE() which creates the C code for fast ODE solving based on a simple syntax (Chapter 5) related to Leibnitz notation. The event data, which can be: a NONMEM or deSolve compatible data frame (Chapter 6), or created with et() or EventTable() for easy simulation of events(Chapter ??) The data frame can be augmented by adding time varying or adding individual covariates (iCov= as needed) rxSolve() which solves the system of equations using initial conditions and parameters to make predictions With multiple subject data, this may be parallelized. With single subject the output data frame is adaptive Covariances and other metrics of uncertanty can be used to simulate while solving. While this is the user guide, there are other places that you can visit for help: This book was assembled on Tue Dec 15 13:57:03 2020 with RxODE version 1.0.0.0 automatically by github actions. "],["related-r-packages.html", "Chapter 2 Related R packages 2.1 ODE solving 2.2 PK Solved systems", " Chapter 2 Related R packages 2.1 ODE solving This is a brief comparison of pharmacometric ODE solving R packages to RxODE. There are several R packages for differential equations. The most popular is deSolve. However for pharmacometrics-specific ODE solving, there are only 2 packages other than RxODE released on CRAN. Each uses compiled code to have faster ODE solving. mrgsolve, which uses C++ lsoda solver to solve ODE systems. The user is required to write hybrid R/C++ code to create a mrgsolve model which is translated to C++ for solving. In contrast, RxODE has a R-like mini-language that is parsed into C code that solves the ODE system. Unlike RxODE, mrgsolve does not currently support symbolic manipulation of ODE systems, like automatic Jacobian calculation or forward sensitivity calculation (RxODE currently supports this and this is the basis of nlmixr’s FOCEi algorithm) dMod, which uses a unique syntax to create “reactions”. These reactions create the underlying ODEs and then created c code for a compiled deSolve model. In contrast RxODE defines ODE systems at a lower level. RxODE’s parsing of the mini-language comes from C, whereas dMod’s parsing comes from R. Like RxODE, dMod supports symbolic manipulation of ODE systems and calculates forward sensitivities and adjoint sensitivities of systems. Unlike RxODE, dMod is not thread-safe since deSolve is not yet thread-safe. And there is one package that is not released on CRAN: PKPDsim which defines models in an R-like syntax and converts the system to compiled code. Like mrgsolve, PKPDsim does not currently support symbolic manipulation of ODE systems. PKPDsim is not thread-safe. The open pharmacometrics open source community is fairly friendly, and the RxODE maintainers has had positive interactions with all of the ODE-solving pharmacometric projects listed. 2.2 PK Solved systems RxODE supports 1-3 compartment models with gradients (using stan math’s auto-differentiation). This currently uses the same equations as PKADVAN to allow time-varying covariates. RxODE can mix ODEs and solved systems. 2.2.1 The following packages for solved PK systems are on CRAN mrgsolve currently has 1-2 compartment (poly-exponential models) models built-in. The solved systems and ODEs cannot currently be mixed. pmxTools currently have 1-3 compartment (super-positioning) models built-in. This is a R-only implementation. PKPDmodels has a one-compartment model with gradients. 2.2.2 Non-CRAN libraries: PKADVAN Provides 1-3 compartment models using non-superpositioning. This allows time-varying covariates. "],["install.html", "Chapter 3 Installation 3.1 Development Version", " Chapter 3 Installation You can install the released version of RxODE from CRAN with: install.packages(&quot;RxODE&quot;) To build models with RxODE, you need a working c compiler. To use parallel threaded solving in RxODE, this c compiler needs to support open-mp. You can check to see if R has working c compiler you can check with: ## install.packages(&quot;pkgbuild&quot;) pkgbuild::has_build_tools(debug = TRUE) If you do not have the toolchain, you can set it up as described by the platform information below: 3.0.1 Windows In windows you may simply use installr to install rtools: install.packages(&quot;installr&quot;) library(installr) install.rtools() Alternatively you can download and install rtools directly. 3.0.2 Mac OSX To get the most speed you need OpenMP enabled and compile RxODE against that binary. Here is some discussion about this: https://mac.r-project.org/openmp/ 3.0.3 Linux To install on linux make sure you install gcc (with openmp support) and gfortran using your distribution’s package manager. 3.1 Development Version Since the development version of RxODE uses StanHeaders, you will need to make sure your compiler is setup to support C++14, as described in the rstan setup page Once the C++ toolchain is setup appropriately, you can install the development version from GitHub with: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;nlmixrdevelopment/RxODE&quot;) "],["gettingStarted.html", "Chapter 4 Getting Started 4.1 Specify ODE parameters and initial conditions 4.2 Specify Dosing and sampling in RxODE 4.3 Solving ODEs", " Chapter 4 Getting Started The model equations can be specified through a text string, a model file or an R expression. Both differential and algebraic equations are permitted. Differential equations are specified by d/dt(var_name) =. Each equation can be separated by a semicolon. To load RxODE package and compile the model: library(RxODE) #&gt; RxODE 1.0.0.0 using 4 threads (see ?getRxThreads) library(units) #&gt; udunits system database from /usr/share/xml/udunits mod1 &lt;-RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) #&gt; qs v0.23.4. 4.1 Specify ODE parameters and initial conditions Model parameters can be defined as named vectors. Names of parameters in the vector must be a superset of parameters in the ODE model, and the order of parameters within the vector is not important. theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects Initial conditions (ICs) can be defined through a vector as well. If the elements are not specified, the initial condition for the compartment is assumed to be zero. inits &lt;- c(eff=1); If you want to specify the initial conditions in the model you can add: eff(0) = 1 4.2 Specify Dosing and sampling in RxODE RxODE provides a simple and very flexible way to specify dosing and sampling through functions that generate an event table. First, an empty event table is generated through the “eventTable()” function: ev &lt;- eventTable(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) Next, use the add.dosing() and add.sampling() functions of the EventTable object to specify the dosing (amounts, frequency and/or times, etc.) and observation times at which to sample the state of the system. These functions can be called multiple times to specify more complex dosing or sampling regiments. Here, these functions are used to specify 10mg BID dosing for 5 days, followed by 20mg QD dosing for 5 days: ev$add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) ev$add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) ev$add.sampling(0:240) If you wish you can also do this with the mattigr pipe operator %&gt;% ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% add.sampling(0:240) The functions get.dosing() and get.sampling() can be used to retrieve information from the event table. head(ev$get.dosing()) #&gt; id low time high cmt amt rate ii addl evid ss dur #&gt; 1 1 NA 0 NA (default) 10000 0 12 9 1 0 0 #&gt; 2 1 NA 120 NA (default) 20000 0 24 4 1 0 0 head(ev$get.sampling()) #&gt; id low time high cmt amt rate ii addl evid ss dur #&gt; 1 1 NA 0 NA (obs) NA NA NA NA 0 NA NA #&gt; 2 1 NA 1 NA (obs) NA NA NA NA 0 NA NA #&gt; 3 1 NA 2 NA (obs) NA NA NA NA 0 NA NA #&gt; 4 1 NA 3 NA (obs) NA NA NA NA 0 NA NA #&gt; 5 1 NA 4 NA (obs) NA NA NA NA 0 NA NA #&gt; 6 1 NA 5 NA (obs) NA NA NA NA 0 NA NA You may notice that these are similar to NONMEM event tables; If you are more familiar with NONMEM data and events you could use them directly with the event table function et ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(0:240) # Add sampling You can see from the above code, you can dose to the compartment named in the RxODE model. This slight deviation from NONMEM can reduce the need for compartment renumbering. These events can also be combined and expanded (to multi-subject events and complex regimens) with rbind, c, seq, and rep. For more information about creating complex dosing regimens using RxODE see the RxODE events vignette. 4.3 Solving ODEs The ODE can now be solved by calling the model object’s run or solve function. Simulation results for all variables in the model are stored in the output matrix x. x &lt;- mod1$solve(theta, ev, inits); knitr::kable(head(x)) time C2 C3 depot centr peri eff 0 0.00000 0.0000000 10000.000 0.000 0.0000 1.000000 1 44.37555 0.9198298 7452.765 1783.897 273.1895 1.084664 2 54.88296 2.6729825 5554.370 2206.295 793.8758 1.180825 3 51.90343 4.4564927 4139.542 2086.518 1323.5783 1.228914 4 44.49738 5.9807076 3085.103 1788.795 1776.2702 1.234610 5 36.48434 7.1774981 2299.255 1466.670 2131.7169 1.214742 You can also solve this and create a RxODE data frame: x &lt;- mod1 %&gt;% rxSolve(theta, ev, inits); x #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters (x$params): ────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ─────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ This returns a modified data frame. You can see the compartment values in the plot below: library(ggplot2) plot(x,C2) + ylab(&quot;Central Concentration&quot;) Or, plot(x,eff) + ylab(&quot;Effect&quot;) Note that the labels are automatically labeled with the units from the initial event table. RxODE extracts units to label the plot (if they are present). "],["syntax.html", "Chapter 5 RxODE syntax 5.1 Example 5.2 Syntax 5.3 Logical Operators 5.4 cmt() changing compartment numbers for states", " Chapter 5 RxODE syntax This briefly describes the syntax used to define models that RxODE will translate into R-callable compiled code. It also describes the communication of variables between R and the RxODE modeling specification. 5.1 Example # An RxODE model specification (this line is a comment). if(comed==0){ # concomitant medication (con-med)? F = 1.0; # full bioavailability w.o. con-med } else { F = 0.80; # 20% reduced bioavailability } C2 = centr/V2; # concentration in the central compartment C3 = peri/V3; # concentration in the peripheral compartment # ODE describing the PK and PD d/dt(depot) = -KA*depot; d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; 5.2 Syntax An RxODE model specification consists of one or more statements optionally terminated by semi-colons ; and optional comments (comments are delimited by # and an end-of-line). A block of statements is a set of statements delimited by curly braces, { ... }. Statements can be either assignments, conditional if/else if/else, while loops (can be exited by break), special statements, or printing statements (for debugging/testing) Assignment statements can be: simple assignments, where the left hand is an identifier (i.e., variable) special time-derivative assignments, where the left hand specifies the change of the amount in the corresponding state variable (compartment) with respect to time e.g., d/dt(depot): special initial-condition assignments where the left hand specifies the compartment of the initial condition being specified, e.g. depot(0) = 0 special model event changes including bioavailability (f(depot)=1), lag time (alag(depot)=0), modeled rate (rate(depot)=2) and modeled duration (dur(depot)=2). An example of these model features and the event specification for the modeled infusions the RxODE data specification is found in RxODE events vignette. special change point syntax, or model times. These model times are specified by mtime(var)=time special Jacobian-derivative assignments, where the left hand specifies the change in the compartment ode with respect to a variable. For example, if d/dt(y) = dy, then a Jacobian for this compartment can be specified as df(y)/dy(dy) = 1. There may be some advantage to obtaining the solution or specifying the Jacobian for very stiff ODE systems. However, for the few stiff systems we tried with LSODA, this actually slightly slowed down the solving. Note that assignment can be done by =, &lt;- or ~. When assigning with the ~ operator, the simple assignments and time-derivative assignments will not be output. Special statements can be: Compartment declaration statements, which can change the default dosing compartment and the assumed compartment number(s) as well as add extra compartment names at the end (useful for multiple-endpoint nlmixr models); These are specified by cmt(compartmentName) Parameter declaration statements, which can make sure the input parameters are in a certain order instead of ordering the parameters by the order they are parsed. This is useful for keeping the parameter order the same when using 2 different ODE models. These are specified by param(par1, par2,...) An example model is shown below: # simple assignment C2 = centr/V2; # time-derivative assignment d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; Expressions in assignment and if statements can be numeric or logical, however, no character nor integer expressions are currently supported. Numeric expressions can include the following numeric operators +, -, *, /, ^ and those mathematical functions defined in the C or the R math libraries (e.g., fabs, exp, log, sin, abs). You may also access the R’s functions in the R math libraries, like lgammafn for the log gamma function. The RxODE syntax is case-sensitive, i.e., ABC is different than abc, Abc, ABc, etc. 5.2.1 Identifiers Like R, Identifiers (variable names) may consist of one or more alphanumeric, underscore _ or period . characters, but the first character cannot be a digit or underscore _. Identifiers in a model specification can refer to: State variables in the dynamic system (e.g., compartments in a pharmacokinetics model). Implied input variable, t (time), tlast (last time point), and podo (oral dose, in the undocumented case of absorption transit models). Special constants like pi or R’s predefined constants. Model parameters (e.g., ka rate of absorption, CL clearance, etc.) Others, as created by assignments as part of the model specification; these are referred as LHS (left-hand side) variable. Currently, the RxODE modeling language only recognizes system state variables and “parameters”, thus, any values that need to be passed from R to the ODE model (e.g., age) should be either passed in the params argument of the integrator function rxSolve() or be in the supplied event data-set. There are certain variable names that are in the RxODE event tables. To avoid confusion, the following event table-related items cannot be assigned, or used as a state but can be accessed in the RxODE code: cmt dvid addl ss rate id However the following variables are cannot be used in a model specification - evid - ii Sometimes RxODE generates variables that are fed back to RxODE. Similarly, nlmixr generates some variables that are used in nlmixr estimation and simulation. These variables start with the either the rx or nlmixr prefixes. To avoid any problems, it is suggested to not use these variables starting with either the rx or nlmixr prefixes. 5.3 Logical Operators Logical operators support the standard R operators ==, != &gt;= &lt;= &gt; and &lt;. Like R these can be in if() or while() statements, ifelse() expressions. Additionally they can be in a standard assignment. For instance, the following is valid: cov1 = covm*(sexf == &quot;female&quot;) + covm*(sexf != &quot;female&quot;) Notice that you can also use character expressions in comparisons. This convenience comes at a cost since character comparisons are slower than numeric expressions. Unlike R, as.numeric or as.integer for these logical statements is not only not needed, but will cause an syntax error if you try to use the function. 5.4 cmt() changing compartment numbers for states The compartment order can be changed with the cmt() syntax in the model. To understand what the cmt() can do you need to understand how RxODE numbers the compartments. Below is an example of how RxODE numbers compartments 5.4.1 How RxODE numbers compartments RxODE automatically assigns compartment numbers when parsing. For example, with the Mavoglurant PBPK model the following model may be used: library(RxODE) pbpk &lt;- RxODE({ KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968) CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; # Hepatic artery blood flow QHA = QLI - (QSP + QPA + QST + QGU); QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) If you look at the summary, you can see where RxODE assigned the compartment number(s) summary(pbpk) #&gt; RxODE 1.0.0-0 model named rx_b16bf3219bce4489d0dc93c431c7a8a0 model (✔ ready). #&gt; DLL: /home/matt/.cache/R/RxODE/rx_b16bf3219bce4489d0dc93c431c7a8a0__.rxd/rx_b16bf3219bce4489d0dc93c431c7a8a0_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;KbBR&quot; &quot;KbMU&quot; &quot;KbAD&quot; &quot;CLint&quot; &quot;KbBO&quot; &quot;KbRB&quot; &quot;CO&quot; &quot;QHT&quot; &quot;QBR&quot; #&gt; [10] &quot;QMU&quot; &quot;QAD&quot; &quot;QSK&quot; &quot;QSP&quot; &quot;QPA&quot; &quot;QLI&quot; &quot;QST&quot; &quot;QGU&quot; &quot;QHA&quot; #&gt; [19] &quot;QBO&quot; &quot;QKI&quot; &quot;QRB&quot; &quot;QLU&quot; &quot;VLU&quot; &quot;VHT&quot; &quot;VBR&quot; &quot;VMU&quot; &quot;VAD&quot; #&gt; [28] &quot;VSK&quot; &quot;VSP&quot; &quot;VPA&quot; &quot;VLI&quot; &quot;VST&quot; &quot;VGU&quot; &quot;VBO&quot; &quot;VKI&quot; &quot;VAB&quot; #&gt; [37] &quot;VVB&quot; &quot;VRB&quot; &quot;fub&quot; &quot;KbLU&quot; &quot;KbHT&quot; &quot;KbSK&quot; &quot;KbSP&quot; &quot;KbPA&quot; &quot;KbLI&quot; #&gt; [46] &quot;KbST&quot; &quot;KbGU&quot; &quot;KbKI&quot; &quot;S15&quot; &quot;C15&quot; #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ RxODE Model Syntax ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; RxODE({ #&gt; KbBR = exp(lKbBR) #&gt; KbMU = exp(lKbMU) #&gt; KbAD = exp(lKbAD) #&gt; CLint = exp(lCLint + eta.LClint) #&gt; KbBO = exp(lKbBO) #&gt; KbRB = exp(lKbRB) #&gt; CO = (187 * WT^0.81) * 60/1000 #&gt; QHT = 4 * CO/100 #&gt; QBR = 12 * CO/100 #&gt; QMU = 17 * CO/100 #&gt; QAD = 5 * CO/100 #&gt; QSK = 5 * CO/100 #&gt; QSP = 3 * CO/100 #&gt; QPA = 1 * CO/100 #&gt; QLI = 25.5 * CO/100 #&gt; QST = 1 * CO/100 #&gt; QGU = 14 * CO/100 #&gt; QHA = QLI - (QSP + QPA + QST + QGU) #&gt; QBO = 5 * CO/100 #&gt; QKI = 19 * CO/100 #&gt; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI) #&gt; QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB #&gt; VLU = (0.76 * WT/100)/1.051 #&gt; VHT = (0.47 * WT/100)/1.03 #&gt; VBR = (2 * WT/100)/1.036 #&gt; VMU = (40 * WT/100)/1.041 #&gt; VAD = (21.42 * WT/100)/0.916 #&gt; VSK = (3.71 * WT/100)/1.116 #&gt; VSP = (0.26 * WT/100)/1.054 #&gt; VPA = (0.14 * WT/100)/1.045 #&gt; VLI = (2.57 * WT/100)/1.04 #&gt; VST = (0.21 * WT/100)/1.05 #&gt; VGU = (1.44 * WT/100)/1.043 #&gt; VBO = (14.29 * WT/100)/1.99 #&gt; VKI = (0.44 * WT/100)/1.05 #&gt; VAB = (2.81 * WT/100)/1.04 #&gt; VVB = (5.62 * WT/100)/1.04 #&gt; VRB = (3.86 * WT/100)/1.04 #&gt; BP = 0.61 #&gt; fup = 0.028 #&gt; fub = fup/BP #&gt; KbLU = exp(0.8334) #&gt; KbHT = exp(1.1205) #&gt; KbSK = exp(-0.5238) #&gt; KbSP = exp(0.3224) #&gt; KbPA = exp(0.3224) #&gt; KbLI = exp(1.7604) #&gt; KbST = exp(0.3224) #&gt; KbGU = exp(1.2026) #&gt; KbKI = exp(1.3171) #&gt; S15 = VVB * BP/1000 #&gt; C15 = Venous_Blood/S15 #&gt; d/dt(Lungs) = QLU * (Venous_Blood/VVB - Lungs/KbLU/VLU) #&gt; d/dt(Heart) = QHT * (Arterial_Blood/VAB - Heart/KbHT/VHT) #&gt; d/dt(Brain) = QBR * (Arterial_Blood/VAB - Brain/KbBR/VBR) #&gt; d/dt(Muscles) = QMU * (Arterial_Blood/VAB - Muscles/KbMU/VMU) #&gt; d/dt(Adipose) = QAD * (Arterial_Blood/VAB - Adipose/KbAD/VAD) #&gt; d/dt(Skin) = QSK * (Arterial_Blood/VAB - Skin/KbSK/VSK) #&gt; d/dt(Spleen) = QSP * (Arterial_Blood/VAB - Spleen/KbSP/VSP) #&gt; d/dt(Pancreas) = QPA * (Arterial_Blood/VAB - Pancreas/KbPA/VPA) #&gt; d/dt(Liver) = QHA * Arterial_Blood/VAB + QSP * Spleen/KbSP/VSP + #&gt; QPA * Pancreas/KbPA/VPA + QST * Stomach/KbST/VST + QGU * #&gt; Gut/KbGU/VGU - CLint * fub * Liver/KbLI/VLI - QLI * Liver/KbLI/VLI #&gt; d/dt(Stomach) = QST * (Arterial_Blood/VAB - Stomach/KbST/VST) #&gt; d/dt(Gut) = QGU * (Arterial_Blood/VAB - Gut/KbGU/VGU) #&gt; d/dt(Bones) = QBO * (Arterial_Blood/VAB - Bones/KbBO/VBO) #&gt; d/dt(Kidneys) = QKI * (Arterial_Blood/VAB - Kidneys/KbKI/VKI) #&gt; d/dt(Arterial_Blood) = QLU * (Lungs/KbLU/VLU - Arterial_Blood/VAB) #&gt; d/dt(Venous_Blood) = QHT * Heart/KbHT/VHT + QBR * Brain/KbBR/VBR + #&gt; QMU * Muscles/KbMU/VMU + QAD * Adipose/KbAD/VAD + QSK * #&gt; Skin/KbSK/VSK + QLI * Liver/KbLI/VLI + QBO * Bones/KbBO/VBO + #&gt; QKI * Kidneys/KbKI/VKI + QRB * Rest_of_Body/KbRB/VRB - #&gt; QLU * Venous_Blood/VVB #&gt; d/dt(Rest_of_Body) = QRB * (Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) #&gt; }) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ In this case, Venous_Blood is assigned to compartment 15. Figuring this out can be inconvenient and also lead to re-numbering compartment in simulation or estimation datasets. While it is easy and probably clearer to specify the compartment by name, other tools only support compartment numbers. Therefore, having a way to number compartment easily can lead to less data modification between multiple tools. 5.4.2 Changing compartments by pre-declaring with cmt() To add the compartments to the RxODE model in the order you desire you simply need to pre-declare the compartments with cmt. For example specifying is Venous_Blood and Skin to be the 1st and 2nd compartments, respectively, is simple: pbpk2 &lt;- RxODE({ ## Now this is the first compartment, ie cmt=1 cmt(Venous_Blood) ## Skin may be a compartment you wish to dose to as well, ## so it is now cmt=2 cmt(Skin) KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968)m CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; QHA = QLI - (QSP + QPA + QST + QGU); # Hepatic artery blood flow QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) You can see this change in the simple printout pbpk2 #&gt; RxODE 1.0.0-0 model named rx_1fda8295091ca6d0012077b24d579018 model (✔ ready). #&gt; x$state: Venous_Blood, Skin, Lungs, Heart, Brain, Muscles, Adipose, Spleen, Pancreas, Liver, Stomach, Gut, Bones, Kidneys, Arterial_Blood, Rest_of_Body #&gt; x$params: lKbBR, lKbMU, lKbAD, lCLint, eta.LClint, lKbBO, lKbRB, WT, BP, fup #&gt; x$lhs: KbBR, KbMU, KbAD, CLint, KbBO, KbRB, CO, QHT, QBR, QMU, QAD, QSK, QSP, QPA, QLI, QST, QGU, QHA, QBO, QKI, QRB, QLU, VLU, VHT, VBR, VMU, VAD, VSK, VSP, VPA, VLI, VST, VGU, VBO, VKI, VAB, VVB, VRB, fub, KbLU, KbHT, KbSK, KbSP, KbPA, KbLI, KbST, KbGU, KbKI, S15, C15 The first two compartments are Venous_Blood followed by Skin. 5.4.3 Appending compartments to the model with cmt() You can also append “compartments” to the model. Because of the ODE solving internals, you cannot add fake compartments to the model until after all the differential equations are defined. For example this is legal: ode.1c.ka &lt;- RxODE({ C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 cmt(eff); }) print(ode.1c.ka) #&gt; RxODE 1.0.0-0 model named rx_673f6105e66276a1ff77b53712cdf722 model (✔ ready). #&gt; $state: depot, center #&gt; $stateExtra: eff #&gt; $params: V, KA, CL #&gt; $lhs: C2 But compartments defined before all the differential equations is not supported; So the model below: ode.1c.ka &lt;- RxODE({ cmt(eff); C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 }) will give an error: Error in rxModelVars_(obj) : Evaluation error: Compartment &#39;eff&#39; needs differential equations defined. "],["events.html", "Chapter 6 RxODE events 6.1 Bolus/Additive Doses 6.2 Infusion Doses 6.3 Steady State 6.4 Reset Events 6.5 Turning off compartments 6.6 Classic RxODE events", " Chapter 6 RxODE events In general, RxODE event tables follow NONMEM dataset convention with the exceptions: The compartment data item (cmt) can be a string/factor with compartment names You may turn off a compartment with a negative compartment number or “-cmt” where cmt is the compartment name. The compartment data item (cmt) can still be a number, the number of the compartment is defined by the appearance of the compartment name in the model. This can be tedious to count, so you can specify compartment numbers easier by using the cmt(cmtName) at the beginning of the model. An additional column, dur can specify the duration of infusions; Bioavailability changes will change the rate of infusion since dur/amt are fixed in the input data. Similarly, when specifying rate/amt for an infusion, the bioavailability will change the infusion duration since rate/amt are fixed in the input data. Some infrequent NONMEM columns are not supported: pcmt, call. Additional events are supported: evid=5 or replace event; This replaces the value of a compartment with the value specified in the amt column. This is equivalent to deSolve=replace. evid=6 or multiply event; This multiplies the value in the compartment with the value specified by the amt column. This is equivalent to deSolve=multiply. Here are the legal entries to a data table: Data Item Meaning Notes id Individual identifier Can be a integer, factor, character, or numeric time Individual time Numeric for each time. amt dose amount Positive for doses zero/NA for observations rate infusion rate When specified the infusion duration will be dur=amt/rate rate = -1, rate modeled; rate = -2, duration modeled dur infusion duration When specified the infusion rate will be rate = amt/dur evid event ID 0=Observation; 1=Dose; 2=Other; 3=Reset; 4=Reset+Dose; 5=Replace; 6=Multiply cmt Compartment Represents compartment #/name for dose/observation ss Steady State Flag 0 = non-steady-state; 1=steady state; 2=steady state +prior states ii Inter-dose Interval Time between doses. addl # of additional doses Number of doses like the current dose. Other notes: The evid can be the classic RxODE (described here) or the NONMEM-style evid described above. NONMEM’s DV is not required; RxODE is a ODE solving framework. NONMEM’s MDV is not required, since it is captured in EVID. Instead of NONMEM-compatible data, it can accept deSolve compatible data-frames. When returning the RxODE solved data-set there are a few additional event ids (EVID) that you may see depending on the solving options: EVID = -1 is when a modeled rate ends (corresponds to rate = -1) EVID = -2 is when a modeled duration ends (corresponds to rate=-2) EVID = -10 when a rate specified zero-order infusion ends (corresponds to rate &gt; 0) EVID = -20 when a duration specified zero-order infusion ends (corresponds to dur &gt; 0) EVID = 101, 102, 103,... These correspond to the 1, 2, 3, … modeled time (mtime). These can only be accessed when solving with the option combination addDosing=TRUE and subsetNonmem=FALSE. If you want to see the classic EVID equivalents you can use addDosing=NA. To illustrate the event types we will use the model from the original RxODE tutorial. library(RxODE) ## Model from RxODE tutorial m1 &lt;-RxODE({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; ## Added modeled bioavaiblity, duration and rate fdepot = 1; durDepot = 8; rateDepot = 1250; C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; f(depot) = fdepot dur(depot) = durDepot rate(depot) = rateDepot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }); 6.1 Bolus/Additive Doses A bolus dose is the default type of dose in RxODE and only requires the amt/dose. Note that this uses the convenience function et() described in the RxODE event tables ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA 0:Observation #&gt; 2 0.0000000 10000 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(C2) + xlab(&quot;Time&quot;) 6.2 Infusion Doses There are a few different type of infusions that RxODE supports: Constant Rate Infusion (rate) Constant Duration Infusion (dur) Estimated Rate of Infusion Estimated Duration of Infusion 6.2.1 Constant Infusions (in terms of duration and rate) The next type of event is an infusion; There are two ways to specify an infusion; The first is the dur keyword. An example of this is: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt ii addl evid dur #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; [h] #&gt; 1 0.0000000 NA NA NA 0:Observation NA #&gt; 2 0.0000000 10000 12 2 1:Dose (Add) 8 #&gt; 3 0.2424242 NA NA NA 0:Observation NA #&gt; 4 0.4848485 NA NA NA 0:Observation NA #&gt; 5 0.7272727 NA NA NA 0:Observation NA #&gt; 6 0.9696970 NA NA NA 0:Observation NA #&gt; 7 1.2121212 NA NA NA 0:Observation NA #&gt; 8 1.4545455 NA NA NA 0:Observation NA #&gt; 9 1.6969697 NA NA NA 0:Observation NA #&gt; 10 1.9393939 NA NA NA 0:Observation NA #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) It can be also specified by the rate component: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=10000/8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA NA 0:Observation #&gt; 2 0.0000000 10000 1250 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) These are the same with the exception of how bioavailability changes the infusion. In the case of modeling rate, a bioavailability decrease, decreases the infusion duration, as in NONMEM. For example: rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) Similarly increasing the bioavailability increases the infusion duration. rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) The rationale for this behavior is that the rate and amt are specified by the event table, so the only thing that can change with a bioavailability increase is the duration of the infusion. If you specify the amt and dur components in the event table, bioavailability changes affect the rate of infusion. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) You can see the side-by-side comparison of bioavailability changes affecting rate instead of duration with these records in the following plots: library(ggplot2) library(patchwork) p1 &lt;- rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;) + ylim(0,5000) p2 &lt;- rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;)+ ylim(0,5000) ## Use patchwork syntax to combine plots p1 * p2 6.2.2 Modeled Rate and Duration of Infusion You can model the duration, which is equivalent to NONMEM’s rate=-2. As a mnemonic you can use the dur=model instead of rate=-2 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=model) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA NA 0:Observation #&gt; 2 0.0000000 10000 -2:dur 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev, c(durDepot=7)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) Similarly, you may also model rate. This is equivalent to NONMEM’s rate=-1 and is how RxODE’s event table specifies the data item as well. You can also use rate=model as a mnemonic: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=model) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA NA 0:Observation #&gt; 2 0.0000000 10000 -1:rate 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev, c(rateDepot=10000/3)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 6.3 Steady State These doses are solved until a steady state is reached with a constant inter-dose interval. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, ss=1) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 5 #&gt; time amt ii evid ss #&gt; [h] &lt;dbl&gt; [h] &lt;evid&gt; &lt;int&gt; #&gt; 1 0.0000000 NA NA 0:Observation NA #&gt; 2 0.0000000 10000 12 1:Dose (Add) 1 #&gt; 3 0.2424242 NA NA 0:Observation NA #&gt; 4 0.4848485 NA NA 0:Observation NA #&gt; 5 0.7272727 NA NA 0:Observation NA #&gt; 6 0.9696970 NA NA 0:Observation NA #&gt; 7 1.2121212 NA NA 0:Observation NA #&gt; 8 1.4545455 NA NA 0:Observation NA #&gt; 9 1.6969697 NA NA 0:Observation NA #&gt; 10 1.9393939 NA NA 0:Observation NA #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(C2) 6.3.1 Steady state for complex dosing By using the ss=2 flag, you can use the super-positioning principle in linear kinetics to get steady state nonstandard dosing (i.e. morning 100 mg vs evening 150 mg). This is done by: Saving all the state values Resetting all the states and solving the system to steady state Adding back all the prior state values ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=24, ss=1) %&gt;% et(time=12, amt=15000, ii=24, ss=2) %&gt;% et(time=24, amt=10000, ii=24, addl=3) %&gt;% et(time=36, amt=15000, ii=24, addl=3) %&gt;% et(seq(0, 64, length.out=500)) library(ggplot2) rxSolve(m1, ev,maxsteps=10000) %&gt;% plot(C2) + annotate(&quot;rect&quot;, xmin=0, xmax=24, ymin=-Inf, ymax=Inf, alpha=0.2) + annotate(&quot;text&quot;, x=12.5, y=7, label=&quot;Initial Steady State Period&quot;) + annotate(&quot;text&quot;, x=44, y=7, label=&quot;Steady State AM/PM dosing&quot;) You can see that it takes a full dose cycle to reach the true complex steady state dosing. 6.3.2 Steady state for constant infusion or zero order processes The last type of steady state that RxODE supports is steady-state constant infusion rate. This can be specified the same way as NONMEM, that is: No inter-dose interval ii=0 A steady state dose, ie ss=1 Either a positive rate (rate&gt;0) or a estimated rate rate=-1. A zero dose, ie amt=0 Once the steady-state constant infusion is achieved, the infusion is turned off when using this record, just like NONMEM. Note that rate=-2 where we model the duration of infusion doesn’t make much sense since we are solving the infusion until steady state. The duration is specified by the steady state solution. Also note that bioavailability changes on this steady state infusion also do not make sense because they neither change the rate or the duration of the steady state infusion. Hence modeled bioavailability on this type of dosing event is ignored. Here is an example: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=0, ss=1,rate=10000/8) p1 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=200000, rate=10000/8) %&gt;% et(0, 250, length.out=1000) p2 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) library(patchwork) p1 / p2 Not only can this be used for PK, it can be used for steady-state disease processes. 6.4 Reset Events Reset events are implemented by evid=3 or evid=reset, for reset and evid=4 for reset and dose. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, evid=reset) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 102 records ─────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 102 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA 0:Observation #&gt; 2 0.0000000 10000 12 3 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA 0:Observation #&gt; # … with 92 more rows The solving show what happens in this system when the system is reset at 6 hours post-dose. rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) You can see all the compartments are reset to their initial values. The next dose start the dosing cycle over. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, amt=10000, evid=4) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 102 records ─────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 102 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA 0:Observation #&gt; 2 0.0000000 10000 12 3 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA 0:Observation #&gt; # … with 92 more rows In this case, the whole system is reset and the dose is given rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 6.5 Turning off compartments You may also turn off a compartment, which is similar to a reset event. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-depot&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 102 records ─────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 102 x 6 #&gt; time cmt amt ii addl evid #&gt; [h] &lt;chr&gt; &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 (obs) NA NA NA 0:Observation #&gt; 2 0.0000000 (default) 10000 12 3 1:Dose (Add) #&gt; 3 0.2424242 (obs) NA NA NA 0:Observation #&gt; 4 0.4848485 (obs) NA NA NA 0:Observation #&gt; 5 0.7272727 (obs) NA NA NA 0:Observation #&gt; 6 0.9696970 (obs) NA NA NA 0:Observation #&gt; 7 1.2121212 (obs) NA NA NA 0:Observation #&gt; 8 1.4545455 (obs) NA NA NA 0:Observation #&gt; 9 1.6969697 (obs) NA NA NA 0:Observation #&gt; 10 1.9393939 (obs) NA NA NA 0:Observation #&gt; # … with 92 more rows Solving shows what this does in the system: rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) In this case, the depot is turned off, and the depot compartment concentrations are set to the initial values but the other compartment concentrations/levels are not reset. When another dose to the depot is administered the depot compartment is turned back on. Note that a dose to a compartment only turns back on the compartment that was dosed. Hence if you turn off the effect compartment, it continues to be off after another dose to the depot. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) To turn back on the compartment, a zero-dose to the compartment or a evid=2 with the compartment would be needed. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(time=12,cmt=&quot;eff&quot;,evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 6.6 Classic RxODE events Originally RxODE supported compound event IDs; RxODE still supports these parameters, but it is often more useful to use the the normal NONMEM dataset standard that is used by many modeling tools like NONMEM, Monolix and nlmixr, described in the RxODE event types article. Classically, RxODE supported event coding in a single event id evid described in the following table. 100+ cmt Infusion/Event Flag &lt;99 Cmt SS flag &amp; Turning of Compartment 100+ cmt 0 = bolus dose &lt; 99 cmt 1 = dose 1 = infusion (rate) 10 = Steady state 1 (equivalent to SS=1) 2 = infusion (dur) 20 = Steady state 2 (equivalent to SS=2) 6 = turn off modeled duration 30 = Turn off a compartment (equivalent to -CMT w/EVID=2) 7 = turn off modeled rate 8 = turn on modeled duration 9 = turn on modeled rate 4 = replace event 5 = multiply event The classic EVID concatenate the numbers in the above table, so an infusion would to compartment 1 would be 10101 and an infusion to compartment 199 would be 119901. EVID = 0 (observations), EVID=2 (other type event) and EVID=3 are all supported. Internally an EVID=9 is a non-observation event and makes sure the system is initialized to zero; EVID=9 should not be manually set. EVID 10-99 represents modeled time interventions, similar to NONMEM’s MTIME. This along with amount (amt) and time columns specify the events in the ODE system. For infusions specified with EVIDs &gt; 100 the amt column represents the rate value. For Infusion flags 1 and 2 +amt turn on the infusion to a specific compartment -amt turn off the infusion to a specific compartment. To specify a dose/duration you place the dosing records at the time the duration starts or stops. For modeled rate/duration infusion flags the on infusion flag must be followed by an off infusion record. These number are concatenated together to form a full RxODE event ID, as shown in the following examples: 6.6.1 Bolus Dose Examples A 100 bolus dose to compartment #1 at time 0 time evid amt 0 101 100 0.5 0 0 1 0 0 A 100 bolus dose to compartment #99 at time 0 time evid amt 0 9901 100 0.5 0 0 1 0 0 A 100 bolus dose to compartment #199 at time 0 time evid amt 0 109901 100 0.5 0 0 1 0 0 6.6.2 Infusion Event Examples Bolus infusion with rate 50 to compartment 1 for 1.5 hr, (modeled bioavailability changes duration of infusion) time evid amt 0 10101 50 0.5 0 0 1 0 0 1.5 10101 -50 Bolus infusion with rate 50 to compartment 1 for 1.5 hr (modeled bioavailability changes rate of infusion) time evid amt 0 20101 50 0.5 0 0 1 0 0 1.5 20101 -50 Modeled rate with amount of 50 time evid amt 0 90101 50 0 70101 50 0.5 0 0 1 0 0 Modeled duration with amount of 50 time evid amt 0 80101 50 0 60101 50 0.5 0 0 1 0 0 6.6.3 Steady State for classic RxODE EVID example Steady state dose to cmt 1 time evid amt 0 110 50 Steady State with super-positioning principle for am 50 and pm 100 dose time evid amt 0 110 50 12 120 100 6.6.4 Turning off a compartment with classic RxODE EVID Turn off the first compartment at time 12 time evid amt 0 110 50 12 130 NA Event coding in RxODE is encoded in a single event number evid. For compartments under 100, this is coded as: This event is 0 for observation events. For a specified compartment a bolus dose is defined as: 100*(Compartment Number) + 1 The dose is then captured in the amt For IV bolus doses the event is defined as: 10000 + 100*(Compartment Number) + 1 The infusion rate is captured in the amt column The infusion is turned off by subtracting amt with the same evid at the stop of the infusion. For compartments greater or equal to 100, the 100s place and above digits are transferred to the 100,000th place digit. For doses to the 99th compartment the evid for a bolus dose would be 9901 and the evid for an infusion would be 19901. For a bolus dose to the 199th compartment the evid for the bolus dose would be 109901. An infusion dosing record for the 199th compartment would be 119901. "]]
