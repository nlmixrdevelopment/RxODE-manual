[["index.html", "RxODE user manual Chapter 1 Introduction", " RxODE user manual Matthew Fidler, Melissa Hallow, Wenping Wang 2021-03-09 Chapter 1 Introduction Welcome to the RxODE user guide; RxODE is an R package for solving and simulating from ode-based models. These models are convert the RxODE mini-language to C and create a compiled dll for fast solving. ODE solving using RxODE has a few key parts: RxODE() which creates the C code for fast ODE solving based on a simple syntax (Chapter 6) related to Leibnitz notation. The event data, which can be: a NONMEM or deSolve compatible data frame (Chapter 7), or created with et() or EventTable() for easy simulation of events (Chapter 11) The data frame can be augmented by adding time varying or adding individual covariates (iCov= as needed) rxSolve() which solves the system of equations using initial conditions and parameters to make predictions With multiple subject data, this may be parallelized. With single subject the output data frame is adaptive Covariances and other metrics of uncertainty can be used to simulate while solving. While this is the user guide, there are other places that you can visit for help: RxODE github pkgdown page RxODE tutorial (accessible in tutorials in Rstudio 1.3+) RxODE github discussions This book was assembled on Tue Mar 9 20:54:44 2021 with RxODE version 1.0.5 automatically by github actions. "],["author.html", "Chapter 2 Authors and Acknowledgments 2.1 Authors 2.2 Contributors 2.3 RxODE acknowledgments:", " Chapter 2 Authors and Acknowledgments 2.1 Authors Matthew L. Fidler (core team/developer/manual) Melissa Hallow (tutorial writer) Wenping Wang (core team/developer) 2.2 Contributors Zufar Mulyukov – Wrote initial version of rxShiny() with modifications from Matthew Fidler Alan Hindmarsh – Lsoda author Awad H. Al-Mohy – Al-Mohy matrix exponential author Ernst Hairer – dop853 author Gerhard Wanner – dop853 author Goro Fuji – Timsort author Hadley Wickham – Author of original findLhs in RxODE, also original author of .s3register (used with permission to anyone, both changed by Matthew Fidler) Jack Dongarra – LApack author Linda Petzold – LSODA Martin Maechler – expm author, used routines from there for inductive linearization Morwenn – Timsort author Nicholas J. Higham – Author of Al-mohy matrix exponential Roger B. Sidje – expokit matrix exponential author Simon Frost – thread safe C implementation of liblsoda Kevin Ushey – Original author of fast factor, modified by Matthew Filder Yu Feng – thread safe liblsoda Matt Dowle – forder primary author (version modified by Matthew Fidler to allow different type of threading and exclude grouping) Cleve Moler – LApack author David Cooley – Author of fast_factor which was modified and now is used RxODE to quickly create factors for IDs without sorting them like R does Daniel C. Dillon – Author of stripping utility to reduce size of RxODE/nlmixr executable Drew Schmidt – Drew Schmidt author of edits for exponential matrix utility taken from R package expm Arun Srinivasan – forder secondary author (version modified by Matthew Fidler to allow different type of threading, indexing and exclude grouping) 2.3 RxODE acknowledgments: Sherwin Sy – Weight based dosing example Justin Wilkins – Documentation updates, logo and testing Emma Schwager – R IJK distribution author J Coligne – dop853 fortran author Bill Denney – Documentation updates, manual and minor bug fixes Tim Waterhouse – Fixed one bug with mac working directories Richard Upton – Helped with solving the ADVAN linCmt() solutions Ross Ihaka – R author Robert Gentleman – R author R core team – R authors "],["related.html", "Chapter 3 Related R packages 3.1 ODE solving 3.2 PK Solved systems", " Chapter 3 Related R packages 3.1 ODE solving This is a brief comparison of pharmacometric ODE solving R packages to RxODE. There are several R packages for differential equations. The most popular is deSolve. However for pharmacometrics-specific ODE solving, there are only 2 packages other than RxODE released on CRAN. Each uses compiled code to have faster ODE solving. mrgsolve, which uses C++ lsoda solver to solve ODE systems. The user is required to write hybrid R/C++ code to create a mrgsolve model which is translated to C++ for solving. In contrast, RxODE has a R-like mini-language that is parsed into C code that solves the ODE system. Unlike RxODE, mrgsolve does not currently support symbolic manipulation of ODE systems, like automatic Jacobian calculation or forward sensitivity calculation (RxODE currently supports this and this is the basis of nlmixr’s FOCEi algorithm) dMod, which uses a unique syntax to create “reactions”. These reactions create the underlying ODEs and then created c code for a compiled deSolve model. In contrast RxODE defines ODE systems at a lower level. RxODE’s parsing of the mini-language comes from C, whereas dMod’s parsing comes from R. Like RxODE, dMod supports symbolic manipulation of ODE systems and calculates forward sensitivities and adjoint sensitivities of systems. Unlike RxODE, dMod is not thread-safe since deSolve is not yet thread-safe. And there is one package that is not released on CRAN: PKPDsim which defines models in an R-like syntax and converts the system to compiled code. Like mrgsolve, PKPDsim does not currently support symbolic manipulation of ODE systems. PKPDsim is not thread-safe. The open pharmacometrics open source community is fairly friendly, and the RxODE maintainers has had positive interactions with all of the ODE-solving pharmacometric projects listed. 3.2 PK Solved systems RxODE supports 1-3 compartment models with gradients (using stan math’s auto-differentiation). This currently uses the same equations as PKADVAN to allow time-varying covariates. RxODE can mix ODEs and solved systems. 3.2.1 The following packages for solved PK systems are on CRAN mrgsolve currently has 1-2 compartment (poly-exponential models) models built-in. The solved systems and ODEs cannot currently be mixed. pmxTools currently have 1-3 compartment (super-positioning) models built-in. This is a R-only implementation. PKPDmodels has a one-compartment model with gradients. 3.2.2 Non-CRAN libraries: PKADVAN Provides 1-3 compartment models using non-superpositioning. This allows time-varying covariates. "],["install.html", "Chapter 4 Installation 4.1 Development Version", " Chapter 4 Installation You can install the released version of RxODE from CRAN with: install.packages(&quot;RxODE&quot;) You can install the development version of RxODE with devtools::install_github(&quot;nlmixrdevelopment/RxODE&quot;) To build models with RxODE, you need a working c compiler. To use parallel threaded solving in RxODE, this c compiler needs to support open-mp. You can check to see if R has working c compiler you can check with: ## install.packages(&quot;pkgbuild&quot;) pkgbuild::has_build_tools(debug = TRUE) If you do not have the toolchain, you can set it up as described by the platform information below: 4.0.1 Windows In windows you may simply use installr to install rtools: install.packages(&quot;installr&quot;) library(installr) install.rtools() Alternatively you can download and install rtools directly. 4.0.2 Mac OSX To get the most speed you need OpenMP enabled and compile RxODE with that compiler. There are various options and the most up to date discussion about this is likely the data.table installation faq for MacOS. The last thing to keep in mind is that RxODE uses the code very similar to the original lsoda which requires the gfortran compiler to be setup as well as the OpenMP compilers. If you are going to be using RxODE and nlmixr together and have an older mac computer, I would suggest trying the following: library(symengine) If this crashes your R session then the binary does not work with your Mac machine. To be able to run nlmixr, you will need to compile this package manually. I will proceed assuming you have homebrew installed on your system. On your system terminal you will need to install the dependencies to compile symengine: brew install cmake gmp mpfr libmpc After installing the dependencies, you need to reinstall symengine: install.packages(&quot;symengine&quot;, type=&quot;source&quot;) library(symengine) 4.0.3 Linux To install on linux make sure you install gcc (with openmp support) and gfortran using your distribution’s package manager. 4.1 Development Version Since the development version of RxODE uses StanHeaders, you will need to make sure your compiler is setup to support C++14, as described in the rstan setup page. For R 4.0, I do not believe this requires modifying the windows toolchain any longer (so it is much easier to setup). Once the C++ toolchain is setup appropriately, you can install the development version from GitHub with: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;nlmixrdevelopment/RxODE&quot;) "],["gettingStarted.html", "Chapter 5 Getting Started 5.1 Specify ODE parameters and initial conditions 5.2 Specify Dosing and sampling in RxODE 5.3 Solving ODEs", " Chapter 5 Getting Started The model equations can be specified through a text string, a model file or an R expression. Both differential and algebraic equations are permitted. Differential equations are specified by d/dt(var_name) =. Each equation can be separated by a semicolon. To load RxODE package and compile the model: library(RxODE) #&gt; RxODE 1.0.5 using 4 threads (see ?getRxThreads) mod1 &lt;-RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) 5.1 Specify ODE parameters and initial conditions Model parameters can be defined as named vectors. Names of parameters in the vector must be a superset of parameters in the ODE model, and the order of parameters within the vector is not important. theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects Initial conditions (ICs) can be defined through a vector as well. If the elements are not specified, the initial condition for the compartment is assumed to be zero. inits &lt;- c(eff=1); If you want to specify the initial conditions in the model you can add: eff(0) = 1 5.2 Specify Dosing and sampling in RxODE RxODE provides a simple and very flexible way to specify dosing and sampling through functions that generate an event table. First, an empty event table is generated through the “eventTable()” function: ev &lt;- eventTable(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) Next, use the add.dosing() and add.sampling() functions of the EventTable object to specify the dosing (amounts, frequency and/or times, etc.) and observation times at which to sample the state of the system. These functions can be called multiple times to specify more complex dosing or sampling regiments. Here, these functions are used to specify 10mg BID dosing for 5 days, followed by 20mg QD dosing for 5 days: ev$add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) ev$add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) ev$add.sampling(0:240) If you wish you can also do this with the mattigr pipe operator %&gt;% ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% add.sampling(0:240) The functions get.dosing() and get.sampling() can be used to retrieve information from the event table. head(ev$get.dosing()) #&gt; id low time high cmt amt rate ii addl evid ss dur #&gt; 1 1 NA 0 NA (default) 10000 0 12 9 1 0 0 #&gt; 2 1 NA 120 NA (default) 20000 0 24 4 1 0 0 head(ev$get.sampling()) #&gt; id low time high cmt amt rate ii addl evid ss dur #&gt; 1 1 NA 0 NA (obs) NA NA NA NA 0 NA NA #&gt; 2 1 NA 1 NA (obs) NA NA NA NA 0 NA NA #&gt; 3 1 NA 2 NA (obs) NA NA NA NA 0 NA NA #&gt; 4 1 NA 3 NA (obs) NA NA NA NA 0 NA NA #&gt; 5 1 NA 4 NA (obs) NA NA NA NA 0 NA NA #&gt; 6 1 NA 5 NA (obs) NA NA NA NA 0 NA NA You may notice that these are similar to NONMEM event tables; If you are more familiar with NONMEM data and events you could use them directly with the event table function et ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(0:240) # Add sampling You can see from the above code, you can dose to the compartment named in the RxODE model. This slight deviation from NONMEM can reduce the need for compartment renumbering. These events can also be combined and expanded (to multi-subject events and complex regimens) with rbind, c, seq, and rep. For more information about creating complex dosing regimens using RxODE see the RxODE events section. 5.3 Solving ODEs The ODE can now be solved by calling the model object’s run or solve function. Simulation results for all variables in the model are stored in the output matrix x. x &lt;- mod1$solve(theta, ev, inits); knitr::kable(head(x)) time C2 C3 depot centr peri eff 0 0.00000 0.0000000 10000.000 0.000 0.0000 1.000000 1 44.37555 0.9198298 7452.765 1783.897 273.1895 1.084664 2 54.88296 2.6729825 5554.370 2206.295 793.8758 1.180825 3 51.90343 4.4564927 4139.542 2086.518 1323.5783 1.228914 4 44.49738 5.9807076 3085.103 1788.795 1776.2702 1.234610 5 36.48434 7.1774981 2299.255 1466.670 2131.7169 1.214742 You can also solve this and create a RxODE data frame: x &lt;- mod1 %&gt;% rxSolve(theta, ev, inits); x #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters (x$params): ────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ─────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ This returns a modified data frame. You can see the compartment values in the plot below: library(ggplot2) plot(x,C2) + ylab(&quot;Central Concentration&quot;) Or, plot(x,eff) + ylab(&quot;Effect&quot;) Note that the labels are automatically labeled with the units from the initial event table. RxODE extracts units to label the plot (if they are present). "],["syntax.html", "Chapter 6 RxODE syntax 6.1 Example 6.2 Syntax 6.3 Logical Operators 6.4 cmt() changing compartment numbers for states", " Chapter 6 RxODE syntax This briefly describes the syntax used to define models that RxODE will translate into R-callable compiled code. It also describes the communication of variables between R and the RxODE modeling specification. 6.1 Example # An RxODE model specification (this line is a comment). if(comed==0){ # concomitant medication (con-med)? F = 1.0; # full bioavailability w.o. con-med } else { F = 0.80; # 20% reduced bioavailability } C2 = centr/V2; # concentration in the central compartment C3 = peri/V3; # concentration in the peripheral compartment # ODE describing the PK and PD d/dt(depot) = -KA*depot; d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; 6.2 Syntax An RxODE model specification consists of one or more statements optionally terminated by semi-colons ; and optional comments (comments are delimited by # and an end-of-line). A block of statements is a set of statements delimited by curly braces, { ... }. Statements can be either assignments, conditional if/else if/else, while loops (can be exited by break), special statements, or printing statements (for debugging/testing) Assignment statements can be: simple assignments, where the left hand is an identifier (i.e., variable) special time-derivative assignments, where the left hand specifies the change of the amount in the corresponding state variable (compartment) with respect to time e.g., d/dt(depot): special initial-condition assignments where the left hand specifies the compartment of the initial condition being specified, e.g. depot(0) = 0 special model event changes including bioavailability (f(depot)=1), lag time (alag(depot)=0), modeled rate (rate(depot)=2) and modeled duration (dur(depot)=2). An example of these model features and the event specification for the modeled infusions the RxODE data specification is found in RxODE events section. special change point syntax, or model times. These model times are specified by mtime(var)=time special Jacobian-derivative assignments, where the left hand specifies the change in the compartment ode with respect to a variable. For example, if d/dt(y) = dy, then a Jacobian for this compartment can be specified as df(y)/dy(dy) = 1. There may be some advantage to obtaining the solution or specifying the Jacobian for very stiff ODE systems. However, for the few stiff systems we tried with LSODA, this actually slightly slowed down the solving. Note that assignment can be done by =, &lt;- or ~. When assigning with the ~ operator, the simple assignments and time-derivative assignments will not be output. Special statements can be: Compartment declaration statements, which can change the default dosing compartment and the assumed compartment number(s) as well as add extra compartment names at the end (useful for multiple-endpoint nlmixr models); These are specified by cmt(compartmentName) Parameter declaration statements, which can make sure the input parameters are in a certain order instead of ordering the parameters by the order they are parsed. This is useful for keeping the parameter order the same when using 2 different ODE models. These are specified by param(par1, par2,...) An example model is shown below: # simple assignment C2 = centr/V2; # time-derivative assignment d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; Expressions in assignment and if statements can be numeric or logical, however, no character nor integer expressions are currently supported. Numeric expressions can include the following numeric operators +, -, *, /, ^ and those mathematical functions defined in the C or the R math libraries (e.g., fabs, exp, log, sin, abs). You may also access the R’s functions in the R math libraries, like lgammafn for the log gamma function. The RxODE syntax is case-sensitive, i.e., ABC is different than abc, Abc, ABc, etc. 6.2.1 Identifiers Like R, Identifiers (variable names) may consist of one or more alphanumeric, underscore _ or period . characters, but the first character cannot be a digit or underscore _. Identifiers in a model specification can refer to: State variables in the dynamic system (e.g., compartments in a pharmacokinetics model). Implied input variable, t (time), tlast (last time point), and podo (oral dose, in the undocumented case of absorption transit models). Special constants like pi or R’s predefined constants. Model parameters (e.g., ka rate of absorption, CL clearance, etc.) Others, as created by assignments as part of the model specification; these are referred as LHS (left-hand side) variable. Currently, the RxODE modeling language only recognizes system state variables and “parameters”, thus, any values that need to be passed from R to the ODE model (e.g., age) should be either passed in the params argument of the integrator function rxSolve() or be in the supplied event data-set. There are certain variable names that are in the RxODE event tables. To avoid confusion, the following event table-related items cannot be assigned, or used as a state but can be accessed in the RxODE code: cmt dvid addl ss rate id However the following variables are cannot be used in a model specification: evid ii Sometimes RxODE generates variables that are fed back to RxODE. Similarly, nlmixr generates some variables that are used in nlmixr estimation and simulation. These variables start with the either the rx or nlmixr prefixes. To avoid any problems, it is suggested to not use these variables starting with either the rx or nlmixr prefixes. 6.3 Logical Operators Logical operators support the standard R operators ==, != &gt;= &lt;= &gt; and &lt;. Like R these can be in if() or while() statements, ifelse() expressions. Additionally they can be in a standard assignment. For instance, the following is valid: cov1 = covm*(sexf == &quot;female&quot;) + covm*(sexf != &quot;female&quot;) Notice that you can also use character expressions in comparisons. This convenience comes at a cost since character comparisons are slower than numeric expressions. Unlike R, as.numeric or as.integer for these logical statements is not only not needed, but will cause an syntax error if you try to use the function. 6.4 cmt() changing compartment numbers for states The compartment order can be changed with the cmt() syntax in the model. To understand what the cmt() can do you need to understand how RxODE numbers the compartments. Below is an example of how RxODE numbers compartments 6.4.1 How RxODE numbers compartments RxODE automatically assigns compartment numbers when parsing. For example, with the Mavoglurant PBPK model the following model may be used: library(RxODE) pbpk &lt;- RxODE({ KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968) CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; # Hepatic artery blood flow QHA = QLI - (QSP + QPA + QST + QGU); QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) If you look at the summary, you can see where RxODE assigned the compartment number(s) summary(pbpk) #&gt; RxODE 1.0.5 model named rx_74372d99e4c72628e9dee8939b90cb49 model (✔ ready). #&gt; DLL: /home/matt/.cache/R/RxODE/rx_74372d99e4c72628e9dee8939b90cb49__.rxd/rx_74372d99e4c72628e9dee8939b90cb49_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;KbBR&quot; &quot;KbMU&quot; &quot;KbAD&quot; &quot;CLint&quot; &quot;KbBO&quot; &quot;KbRB&quot; &quot;CO&quot; &quot;QHT&quot; &quot;QBR&quot; #&gt; [10] &quot;QMU&quot; &quot;QAD&quot; &quot;QSK&quot; &quot;QSP&quot; &quot;QPA&quot; &quot;QLI&quot; &quot;QST&quot; &quot;QGU&quot; &quot;QHA&quot; #&gt; [19] &quot;QBO&quot; &quot;QKI&quot; &quot;QRB&quot; &quot;QLU&quot; &quot;VLU&quot; &quot;VHT&quot; &quot;VBR&quot; &quot;VMU&quot; &quot;VAD&quot; #&gt; [28] &quot;VSK&quot; &quot;VSP&quot; &quot;VPA&quot; &quot;VLI&quot; &quot;VST&quot; &quot;VGU&quot; &quot;VBO&quot; &quot;VKI&quot; &quot;VAB&quot; #&gt; [37] &quot;VVB&quot; &quot;VRB&quot; &quot;fub&quot; &quot;KbLU&quot; &quot;KbHT&quot; &quot;KbSK&quot; &quot;KbSP&quot; &quot;KbPA&quot; &quot;KbLI&quot; #&gt; [46] &quot;KbST&quot; &quot;KbGU&quot; &quot;KbKI&quot; &quot;S15&quot; &quot;C15&quot; #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ RxODE Model Syntax ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; RxODE({ #&gt; KbBR = exp(lKbBR) #&gt; KbMU = exp(lKbMU) #&gt; KbAD = exp(lKbAD) #&gt; CLint = exp(lCLint + eta.LClint) #&gt; KbBO = exp(lKbBO) #&gt; KbRB = exp(lKbRB) #&gt; CO = (187 * WT^0.81) * 60/1000 #&gt; QHT = 4 * CO/100 #&gt; QBR = 12 * CO/100 #&gt; QMU = 17 * CO/100 #&gt; QAD = 5 * CO/100 #&gt; QSK = 5 * CO/100 #&gt; QSP = 3 * CO/100 #&gt; QPA = 1 * CO/100 #&gt; QLI = 25.5 * CO/100 #&gt; QST = 1 * CO/100 #&gt; QGU = 14 * CO/100 #&gt; QHA = QLI - (QSP + QPA + QST + QGU) #&gt; QBO = 5 * CO/100 #&gt; QKI = 19 * CO/100 #&gt; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI) #&gt; QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB #&gt; VLU = (0.76 * WT/100)/1.051 #&gt; VHT = (0.47 * WT/100)/1.03 #&gt; VBR = (2 * WT/100)/1.036 #&gt; VMU = (40 * WT/100)/1.041 #&gt; VAD = (21.42 * WT/100)/0.916 #&gt; VSK = (3.71 * WT/100)/1.116 #&gt; VSP = (0.26 * WT/100)/1.054 #&gt; VPA = (0.14 * WT/100)/1.045 #&gt; VLI = (2.57 * WT/100)/1.04 #&gt; VST = (0.21 * WT/100)/1.05 #&gt; VGU = (1.44 * WT/100)/1.043 #&gt; VBO = (14.29 * WT/100)/1.99 #&gt; VKI = (0.44 * WT/100)/1.05 #&gt; VAB = (2.81 * WT/100)/1.04 #&gt; VVB = (5.62 * WT/100)/1.04 #&gt; VRB = (3.86 * WT/100)/1.04 #&gt; BP = 0.61 #&gt; fup = 0.028 #&gt; fub = fup/BP #&gt; KbLU = exp(0.8334) #&gt; KbHT = exp(1.1205) #&gt; KbSK = exp(-0.5238) #&gt; KbSP = exp(0.3224) #&gt; KbPA = exp(0.3224) #&gt; KbLI = exp(1.7604) #&gt; KbST = exp(0.3224) #&gt; KbGU = exp(1.2026) #&gt; KbKI = exp(1.3171) #&gt; S15 = VVB * BP/1000 #&gt; C15 = Venous_Blood/S15 #&gt; d/dt(Lungs) = QLU * (Venous_Blood/VVB - Lungs/KbLU/VLU) #&gt; d/dt(Heart) = QHT * (Arterial_Blood/VAB - Heart/KbHT/VHT) #&gt; d/dt(Brain) = QBR * (Arterial_Blood/VAB - Brain/KbBR/VBR) #&gt; d/dt(Muscles) = QMU * (Arterial_Blood/VAB - Muscles/KbMU/VMU) #&gt; d/dt(Adipose) = QAD * (Arterial_Blood/VAB - Adipose/KbAD/VAD) #&gt; d/dt(Skin) = QSK * (Arterial_Blood/VAB - Skin/KbSK/VSK) #&gt; d/dt(Spleen) = QSP * (Arterial_Blood/VAB - Spleen/KbSP/VSP) #&gt; d/dt(Pancreas) = QPA * (Arterial_Blood/VAB - Pancreas/KbPA/VPA) #&gt; d/dt(Liver) = QHA * Arterial_Blood/VAB + QSP * Spleen/KbSP/VSP + #&gt; QPA * Pancreas/KbPA/VPA + QST * Stomach/KbST/VST + QGU * #&gt; Gut/KbGU/VGU - CLint * fub * Liver/KbLI/VLI - QLI * Liver/KbLI/VLI #&gt; d/dt(Stomach) = QST * (Arterial_Blood/VAB - Stomach/KbST/VST) #&gt; d/dt(Gut) = QGU * (Arterial_Blood/VAB - Gut/KbGU/VGU) #&gt; d/dt(Bones) = QBO * (Arterial_Blood/VAB - Bones/KbBO/VBO) #&gt; d/dt(Kidneys) = QKI * (Arterial_Blood/VAB - Kidneys/KbKI/VKI) #&gt; d/dt(Arterial_Blood) = QLU * (Lungs/KbLU/VLU - Arterial_Blood/VAB) #&gt; d/dt(Venous_Blood) = QHT * Heart/KbHT/VHT + QBR * Brain/KbBR/VBR + #&gt; QMU * Muscles/KbMU/VMU + QAD * Adipose/KbAD/VAD + QSK * #&gt; Skin/KbSK/VSK + QLI * Liver/KbLI/VLI + QBO * Bones/KbBO/VBO + #&gt; QKI * Kidneys/KbKI/VKI + QRB * Rest_of_Body/KbRB/VRB - #&gt; QLU * Venous_Blood/VVB #&gt; d/dt(Rest_of_Body) = QRB * (Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) #&gt; }) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ In this case, Venous_Blood is assigned to compartment 15. Figuring this out can be inconvenient and also lead to re-numbering compartment in simulation or estimation datasets. While it is easy and probably clearer to specify the compartment by name, other tools only support compartment numbers. Therefore, having a way to number compartment easily can lead to less data modification between multiple tools. 6.4.2 Changing compartments by pre-declaring with cmt() To add the compartments to the RxODE model in the order you desire you simply need to pre-declare the compartments with cmt. For example specifying is Venous_Blood and Skin to be the 1st and 2nd compartments, respectively, is simple: pbpk2 &lt;- RxODE({ ## Now this is the first compartment, ie cmt=1 cmt(Venous_Blood) ## Skin may be a compartment you wish to dose to as well, ## so it is now cmt=2 cmt(Skin) KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968)m CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; QHA = QLI - (QSP + QPA + QST + QGU); # Hepatic artery blood flow QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) You can see this change in the simple printout pbpk2 #&gt; RxODE 1.0.5 model named rx_a65bdb529b0485f601cec6187b5faaf5 model (✔ ready). #&gt; x$state: Venous_Blood, Skin, Lungs, Heart, Brain, Muscles, Adipose, Spleen, Pancreas, Liver, Stomach, Gut, Bones, Kidneys, Arterial_Blood, Rest_of_Body #&gt; x$params: lKbBR, lKbMU, lKbAD, lCLint, eta.LClint, lKbBO, lKbRB, WT, BP, fup #&gt; x$lhs: KbBR, KbMU, KbAD, CLint, KbBO, KbRB, CO, QHT, QBR, QMU, QAD, QSK, QSP, QPA, QLI, QST, QGU, QHA, QBO, QKI, QRB, QLU, VLU, VHT, VBR, VMU, VAD, VSK, VSP, VPA, VLI, VST, VGU, VBO, VKI, VAB, VVB, VRB, fub, KbLU, KbHT, KbSK, KbSP, KbPA, KbLI, KbST, KbGU, KbKI, S15, C15 The first two compartments are Venous_Blood followed by Skin. 6.4.3 Appending compartments to the model with cmt() You can also append “compartments” to the model. Because of the ODE solving internals, you cannot add fake compartments to the model until after all the differential equations are defined. For example this is legal: ode.1c.ka &lt;- RxODE({ C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 cmt(eff); }) print(ode.1c.ka) #&gt; RxODE 1.0.5 model named rx_47c1eb3facce5268a288e5652999299e model (✔ ready). #&gt; $state: depot, center #&gt; $stateExtra: eff #&gt; $params: V, KA, CL #&gt; $lhs: C2 But compartments defined before all the differential equations is not supported; So the model below: ode.1c.ka &lt;- RxODE({ cmt(eff); C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 }) will give an error: Error in rxModelVars_(obj) : Evaluation error: Compartment &#39;eff&#39; needs differential equations defined. "],["events.html", "Chapter 7 RxODE events 7.1 RxODE event tables 7.2 Bolus/Additive Doses 7.3 Infusion Doses 7.4 Steady State 7.5 Reset Events 7.6 Turning off compartments 7.7 Classic RxODE events 7.8 Datasets for RxODE &amp; nlmixr 7.9 Columns Described by Type of Use 7.10 Details for Specific Dataset Columns", " Chapter 7 RxODE events 7.1 RxODE event tables In general, RxODE event tables follow NONMEM dataset convention with the exceptions: The compartment data item (cmt) can be a string/factor with compartment names You may turn off a compartment with a negative compartment number or “-cmt” where cmt is the compartment name. The compartment data item (cmt) can still be a number, the number of the compartment is defined by the appearance of the compartment name in the model. This can be tedious to count, so you can specify compartment numbers easier by using the cmt(cmtName) at the beginning of the model. An additional column, dur can specify the duration of infusions; Bioavailability changes will change the rate of infusion since dur/amt are fixed in the input data. Similarly, when specifying rate/amt for an infusion, the bioavailability will change the infusion duration since rate/amt are fixed in the input data. Some infrequent NONMEM columns are not supported: pcmt, call. Additional events are supported: evid=5 or replace event; This replaces the value of a compartment with the value specified in the amt column. This is equivalent to deSolve=replace. evid=6 or multiply event; This multiplies the value in the compartment with the value specified by the amt column. This is equivalent to deSolve=multiply. Here are the legal entries to a data table: Data Item Meaning Notes id Individual identifier Can be a integer, factor, character, or numeric time Individual time Numeric for each time. amt dose amount Positive for doses zero/NA for observations rate infusion rate When specified the infusion duration will be dur=amt/rate rate = -1, rate modeled; rate = -2, duration modeled dur infusion duration When specified the infusion rate will be rate = amt/dur evid event ID 0=Observation; 1=Dose; 2=Other; 3=Reset; 4=Reset+Dose; 5=Replace; 6=Multiply cmt Compartment Represents compartment #/name for dose/observation ss Steady State Flag 0 = non-steady-state; 1=steady state; 2=steady state +prior states ii Inter-dose Interval Time between doses. addl # of additional doses Number of doses like the current dose. Other notes: The evid can be the classic RxODE (described here) or the NONMEM-style evid described above. NONMEM’s DV is not required; RxODE is a ODE solving framework. NONMEM’s MDV is not required, since it is captured in EVID. Instead of NONMEM-compatible data, it can accept deSolve compatible data-frames. When returning the RxODE solved data-set there are a few additional event ids (EVID) that you may see depending on the solving options: EVID = -1 is when a modeled rate ends (corresponds to rate = -1) EVID = -2 is when a modeled duration ends (corresponds to rate=-2) EVID = -10 when a rate specified zero-order infusion ends (corresponds to rate &gt; 0) EVID = -20 when a duration specified zero-order infusion ends (corresponds to dur &gt; 0) EVID = 101, 102, 103,... These correspond to the 1, 2, 3, … modeled time (mtime). These can only be accessed when solving with the option combination addDosing=TRUE and subsetNonmem=FALSE. If you want to see the classic EVID equivalents you can use addDosing=NA. To illustrate the event types we will use the model from the original RxODE tutorial. library(RxODE) ### Model from RxODE tutorial m1 &lt;-RxODE({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; ## Added modeled bioavaiblity, duration and rate fdepot = 1; durDepot = 8; rateDepot = 1250; C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; f(depot) = fdepot dur(depot) = durDepot rate(depot) = rateDepot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }); 7.2 Bolus/Additive Doses A bolus dose is the default type of dose in RxODE and only requires the amt/dose. Note that this uses the convenience function et() described in the RxODE event tables ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA 0:Observation #&gt; 2 0.0000000 10000 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(C2) + xlab(&quot;Time&quot;) 7.3 Infusion Doses There are a few different type of infusions that RxODE supports: Constant Rate Infusion (rate) Constant Duration Infusion (dur) Estimated Rate of Infusion Estimated Duration of Infusion 7.3.1 Constant Infusion (in terms of duration and rate) The next type of event is an infusion; There are two ways to specify an infusion; The first is the dur keyword. An example of this is: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt ii addl evid dur #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; [h] #&gt; 1 0.0000000 NA NA NA 0:Observation NA #&gt; 2 0.0000000 10000 12 2 1:Dose (Add) 8 #&gt; 3 0.2424242 NA NA NA 0:Observation NA #&gt; 4 0.4848485 NA NA NA 0:Observation NA #&gt; 5 0.7272727 NA NA NA 0:Observation NA #&gt; 6 0.9696970 NA NA NA 0:Observation NA #&gt; 7 1.2121212 NA NA NA 0:Observation NA #&gt; 8 1.4545455 NA NA NA 0:Observation NA #&gt; 9 1.6969697 NA NA NA 0:Observation NA #&gt; 10 1.9393939 NA NA NA 0:Observation NA #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) It can be also specified by the rate component: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=10000/8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA NA 0:Observation #&gt; 2 0.0000000 10000 1250 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) These are the same with the exception of how bioavailability changes the infusion. In the case of modeling rate, a bioavailability decrease, decreases the infusion duration, as in NONMEM. For example: rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) Similarly increasing the bioavailability increases the infusion duration. rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) The rationale for this behavior is that the rate and amt are specified by the event table, so the only thing that can change with a bioavailability increase is the duration of the infusion. If you specify the amt and dur components in the event table, bioavailability changes affect the rate of infusion. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) You can see the side-by-side comparison of bioavailability changes affecting rate instead of duration with these records in the following plots: library(ggplot2) library(patchwork) p1 &lt;- rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;) + ylim(0,5000) p2 &lt;- rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;)+ ylim(0,5000) ### Use patchwork syntax to combine plots p1 * p2 7.3.2 Modeled Rate and Duration of Infusion You can model the duration, which is equivalent to NONMEM’s rate=-2. As a mnemonic you can use the dur=model instead of rate=-2 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=model) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA NA 0:Observation #&gt; 2 0.0000000 10000 -2:dur 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev, c(durDepot=7)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) Similarly, you may also model rate. This is equivalent to NONMEM’s rate=-1 and is how RxODE’s event table specifies the data item as well. You can also use rate=model as a mnemonic: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=model) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA NA 0:Observation #&gt; 2 0.0000000 10000 -1:rate 12 2 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA NA 0:Observation #&gt; # … with 91 more rows rxSolve(m1, ev, c(rateDepot=10000/3)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 7.4 Steady State These doses are solved until a steady state is reached with a constant inter-dose interval. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, ss=1) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 101 records ─────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 101 x 5 #&gt; time amt ii evid ss #&gt; [h] &lt;dbl&gt; [h] &lt;evid&gt; &lt;int&gt; #&gt; 1 0.0000000 NA NA 0:Observation NA #&gt; 2 0.0000000 10000 12 1:Dose (Add) 1 #&gt; 3 0.2424242 NA NA 0:Observation NA #&gt; 4 0.4848485 NA NA 0:Observation NA #&gt; 5 0.7272727 NA NA 0:Observation NA #&gt; 6 0.9696970 NA NA 0:Observation NA #&gt; 7 1.2121212 NA NA 0:Observation NA #&gt; 8 1.4545455 NA NA 0:Observation NA #&gt; 9 1.6969697 NA NA 0:Observation NA #&gt; 10 1.9393939 NA NA 0:Observation NA #&gt; # … with 91 more rows rxSolve(m1, ev) %&gt;% plot(C2) 7.4.1 Steady state for complex dosing By using the ss=2 flag, you can use the super-positioning principle in linear kinetics to get steady state nonstandard dosing (i.e. morning 100 mg vs evening 150 mg). This is done by: Saving all the state values Resetting all the states and solving the system to steady state Adding back all the prior state values ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=24, ss=1) %&gt;% et(time=12, amt=15000, ii=24, ss=2) %&gt;% et(time=24, amt=10000, ii=24, addl=3) %&gt;% et(time=36, amt=15000, ii=24, addl=3) %&gt;% et(seq(0, 64, length.out=500)) library(ggplot2) rxSolve(m1, ev,maxsteps=10000) %&gt;% plot(C2) + annotate(&quot;rect&quot;, xmin=0, xmax=24, ymin=-Inf, ymax=Inf, alpha=0.2) + annotate(&quot;text&quot;, x=12.5, y=7, label=&quot;Initial Steady State Period&quot;) + annotate(&quot;text&quot;, x=44, y=7, label=&quot;Steady State AM/PM dosing&quot;) You can see that it takes a full dose cycle to reach the true complex steady state dosing. 7.4.2 Steady state for constant infusion or zero order processes The last type of steady state that RxODE supports is steady-state constant infusion rate. This can be specified the same way as NONMEM, that is: No inter-dose interval ii=0 A steady state dose, ie ss=1 Either a positive rate (rate&gt;0) or a estimated rate rate=-1. A zero dose, ie amt=0 Once the steady-state constant infusion is achieved, the infusion is turned off when using this record, just like NONMEM. Note that rate=-2 where we model the duration of infusion doesn’t make much sense since we are solving the infusion until steady state. The duration is specified by the steady state solution. Also note that bioavailability changes on this steady state infusion also do not make sense because they neither change the rate or the duration of the steady state infusion. Hence modeled bioavailability on this type of dosing event is ignored. Here is an example: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=0, ss=1,rate=10000/8) p1 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=200000, rate=10000/8) %&gt;% et(0, 250, length.out=1000) p2 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) library(patchwork) p1 / p2 Not only can this be used for PK, it can be used for steady-state disease processes. 7.5 Reset Events Reset events are implemented by evid=3 or evid=reset, for reset and evid=4 for reset and dose. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, evid=reset) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 102 records ─────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 102 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA 0:Observation #&gt; 2 0.0000000 10000 12 3 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA 0:Observation #&gt; # … with 92 more rows The solving show what happens in this system when the system is reset at 6 hours post-dose. rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) You can see all the compartments are reset to their initial values. The next dose start the dosing cycle over. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, amt=10000, evid=4) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 102 records ─────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 102 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 NA NA NA 0:Observation #&gt; 2 0.0000000 10000 12 3 1:Dose (Add) #&gt; 3 0.2424242 NA NA NA 0:Observation #&gt; 4 0.4848485 NA NA NA 0:Observation #&gt; 5 0.7272727 NA NA NA 0:Observation #&gt; 6 0.9696970 NA NA NA 0:Observation #&gt; 7 1.2121212 NA NA NA 0:Observation #&gt; 8 1.4545455 NA NA NA 0:Observation #&gt; 9 1.6969697 NA NA NA 0:Observation #&gt; 10 1.9393939 NA NA NA 0:Observation #&gt; # … with 92 more rows In this case, the whole system is reset and the dose is given rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 7.6 Turning off compartments You may also turn off a compartment, which is similar to a reset event. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-depot&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ──────────────── EventTable with 102 records ─────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 100 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 102 x 6 #&gt; time cmt amt ii addl evid #&gt; [h] &lt;chr&gt; &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0.0000000 (obs) NA NA NA 0:Observation #&gt; 2 0.0000000 (default) 10000 12 3 1:Dose (Add) #&gt; 3 0.2424242 (obs) NA NA NA 0:Observation #&gt; 4 0.4848485 (obs) NA NA NA 0:Observation #&gt; 5 0.7272727 (obs) NA NA NA 0:Observation #&gt; 6 0.9696970 (obs) NA NA NA 0:Observation #&gt; 7 1.2121212 (obs) NA NA NA 0:Observation #&gt; 8 1.4545455 (obs) NA NA NA 0:Observation #&gt; 9 1.6969697 (obs) NA NA NA 0:Observation #&gt; 10 1.9393939 (obs) NA NA NA 0:Observation #&gt; # … with 92 more rows Solving shows what this does in the system: rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) In this case, the depot is turned off, and the depot compartment concentrations are set to the initial values but the other compartment concentrations/levels are not reset. When another dose to the depot is administered the depot compartment is turned back on. Note that a dose to a compartment only turns back on the compartment that was dosed. Hence if you turn off the effect compartment, it continues to be off after another dose to the depot. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) To turn back on the compartment, a zero-dose to the compartment or a evid=2 with the compartment would be needed. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(time=12,cmt=&quot;eff&quot;,evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 7.7 Classic RxODE events Originally RxODE supported compound event IDs; RxODE still supports these parameters, but it is often more useful to use the the normal NONMEM dataset standard that is used by many modeling tools like NONMEM, Monolix and nlmixr, described in the RxODE event types article. Classically, RxODE supported event coding in a single event id evid described in the following table. 100+ cmt Infusion/Event Flag &lt;99 Cmt SS flag &amp; Turning of Compartment 100+ cmt 0 = bolus dose &lt; 99 cmt 1 = dose 1 = infusion (rate) 10 = Steady state 1 (equivalent to SS=1) 2 = infusion (dur) 20 = Steady state 2 (equivalent to SS=2) 6 = turn off modeled duration 30 = Turn off a compartment (equivalent to -CMT w/EVID=2) 7 = turn off modeled rate 8 = turn on modeled duration 9 = turn on modeled rate 4 = replace event 5 = multiply event The classic EVID concatenate the numbers in the above table, so an infusion would to compartment 1 would be 10101 and an infusion to compartment 199 would be 119901. EVID = 0 (observations), EVID=2 (other type event) and EVID=3 are all supported. Internally an EVID=9 is a non-observation event and makes sure the system is initialized to zero; EVID=9 should not be manually set. EVID 10-99 represents modeled time interventions, similar to NONMEM’s MTIME. This along with amount (amt) and time columns specify the events in the ODE system. For infusions specified with EVIDs &gt; 100 the amt column represents the rate value. For Infusion flags 1 and 2 +amt turn on the infusion to a specific compartment -amt turn off the infusion to a specific compartment. To specify a dose/duration you place the dosing records at the time the duration starts or stops. For modeled rate/duration infusion flags the on infusion flag must be followed by an off infusion record. These number are concatenated together to form a full RxODE event ID, as shown in the following examples: 7.7.1 Bolus Dose Examples A 100 bolus dose to compartment #1 at time 0 time evid amt 0 101 100 0.5 0 0 1 0 0 A 100 bolus dose to compartment #99 at time 0 time evid amt 0 9901 100 0.5 0 0 1 0 0 A 100 bolus dose to compartment #199 at time 0 time evid amt 0 109901 100 0.5 0 0 1 0 0 7.7.2 Infusion Event Examples Bolus infusion with rate 50 to compartment 1 for 1.5 hr, (modeled bioavailability changes duration of infusion) time evid amt 0 10101 50 0.5 0 0 1 0 0 1.5 10101 -50 Bolus infusion with rate 50 to compartment 1 for 1.5 hr (modeled bioavailability changes rate of infusion) time evid amt 0 20101 50 0.5 0 0 1 0 0 1.5 20101 -50 Modeled rate with amount of 50 time evid amt 0 90101 50 0 70101 50 0.5 0 0 1 0 0 Modeled duration with amount of 50 time evid amt 0 80101 50 0 60101 50 0.5 0 0 1 0 0 7.7.3 Steady State for classic RxODE EVID example Steady state dose to cmt 1 time evid amt 0 110 50 Steady State with super-positioning principle for am 50 and pm 100 dose time evid amt 0 110 50 12 120 100 7.7.4 Turning off a compartment with classic RxODE EVID Turn off the first compartment at time 12 time evid amt 0 110 50 12 130 NA Event coding in RxODE is encoded in a single event number evid. For compartments under 100, this is coded as: This event is 0 for observation events. For a specified compartment a bolus dose is defined as: 100*(Compartment Number) + 1 The dose is then captured in the amt For IV bolus doses the event is defined as: 10000 + 100*(Compartment Number) + 1 The infusion rate is captured in the amt column The infusion is turned off by subtracting amt with the same evid at the stop of the infusion. For compartments greater or equal to 100, the 100s place and above digits are transferred to the 100,000th place digit. For doses to the 99th compartment the evid for a bolus dose would be 9901 and the evid for an infusion would be 19901. For a bolus dose to the 199th compartment the evid for the bolus dose would be 109901. An infusion dosing record for the 199th compartment would be 119901. 7.8 Datasets for RxODE &amp; nlmixr Data for input into nlmixr is the same type of data input for RxODE, and it is similar to data for NONMEM (most NONMEM-ready datasets can be used directly in nlmixr). 7.9 Columns Described by Type of Use 7.9.1 Subject Identification Columns The subject identification column separates subjects for identification of random effects. ID: A subject identifier that may be an integer, character, or factor. 7.9.2 Observation Columns Observation columns are used to indicate the dependent variable and how to use or measure it. DV: A numeric column with the measurement CENS: A numeric column for indication of censoring, such as below the limit of quantification for an assay. LIMIT: A numeric column for helping indicate the type of censoring, such as below the limit of quantification for an assay. MDV: An indicator for missing DV values CMT: The name or number of the compartment DVID: The dependent variable identifier EVID The event identifier 7.9.3 Dosing Columns AMT: The amount of the dose CMT: The name or number of the compartment EVID: The event identifier ADDL: The number of additional doses RATE or DUR: The rate or duration of a dose 7.9.4 Covariate Columns 7.10 Details for Specific Dataset Columns The details below are sorted alphabetically by column name. For grouping by use, see the documentation above. 7.10.1 AMT Column The AMT column defines the amount of a dose. For observation rows, it should be 0 or NA. For dosing rows, it is the amount of the dose administered to the CMT. If the dose has a zero-order rate (such as a constant infusion), the infusion may be setup using the RATE or DUR column. 7.10.2 CENS/LIMIT Columns The CENS column is an indicator column indicating if censoring occurred. For pharmacokinetic modeling, censoring is typically when a sample is below the limit of quantification. Internally RxODE saves these values so that nlmixr can use them in likelihood calculations. CENS = 0 indicates that the value in DV is measured without censoring. CENS = 1 indicates that a value is left censored (or below the limit of quantitation) and that the value in DV is censoring/quantitation limit. CENS = -1 indicates that a value is right censored (or above limit of quantitation) and that the value in DV is censoring/quantitation limit. The LIMIT is additional information about how censoring is handled with nlmixr and is stored in RxODE’s data structure as well. When a value is left censored, like below a limit of 1 you may also believe that the value is above a certain threshold, like zero. In this case, a limit of 0 indicates that the censored value is between 0 and 1. In short when: CENS = 0 a LIMIT is ignored because the observation is not censored CENS = 1 the value is censored between (LIMIT, DV) CENS = -1 the value is censored between (DV, LIMIT) 7.10.3 CMT Column The CMT column indicates the compartment where an event occurs. When given as a character string or factor (the preferred method), it is matched by name in the model. When given as an integer, it is matched by the order that compartments appear in the model. 7.10.4 DUR Column The DUR column defines the duration of an infusion. It is used to set the duration of a zero-order rate of infusion. 7.10.5 DV Column The DV column indicates the current measurement in the current compartment (see CMT) with the current measurement identifier (see DVID) which may be missing (see MDV) or censored (see CENS). 7.10.6 DVID Column TODO 7.10.7 EVID Column The EVID column is the event identifier for a row of data. For observation records, it will be 0. For normal dosing records, it will be 1. Many more EVID values are detailed in the RxODE Event Types and Classic RxODE Events vignettes. 7.10.8 ID Column The ID column is a subject identifier. This column is used to separate one individual (usually a single person or animal) from another. In the model, the ID column is used to separate individuals. The numerical integrator re-initializes with each new individual, and new values for all random effects are selected. 7.10.9 RATE Column TODO "],["et.html", "Chapter 8 Easily creating RxODE events 8.1 Adding doses to the event table 8.2 Adding sampling to an event table 8.3 Expand the event table to a multi-subject event table. 8.4 Add doses and samples within a sampling window 8.5 Combining event tables 8.6 Sequencing event tables 8.7 Repeating event tables 8.8 Combining event tables with rbind 8.9 Expanding events 8.10 Event tables in Rstudio Notebooks", " Chapter 8 Easily creating RxODE events An event table in RxODE is a specialized data frame that acts as a container for all of RxODE’s events and observation times. To create an RxODE event table you may use the code eventTable(), et(), or even create your own data frame with the right event information contained in it. This is closely related to the types of events that RxODE supports. library(RxODE) library(units) #&gt; udunits database from /usr/share/xml/udunits/udunits2.xml (ev &lt;- eventTable()) #&gt; ───────────────── EventTable with 0 records ──────────────── #&gt; #&gt; 0 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) or (ev &lt;- et()) #&gt; ───────────────── EventTable with 0 records ──────────────── #&gt; #&gt; 0 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) With this event table you can add sampling/observations or doses by piping or direct access. This is a short table of the two main functions to create dosing add.dosing() et() Description dose amt Dose/Rate/Duration amount nbr.doses addl Additional doses or number of doses dosing.interval ii Dosing Interval dosing.to cmt Dosing Compartment rate rate Infusion rate start.time time Dosing start time dur Infusion Duration Sampling times can be added with add.sampling( sampling times ) or et( sampling times ). Dosing intervals and sampling windows are also supported. For these models, we can illustrate by using the model shared in the RxODE tutorial: ## Model from RxODE tutorial m1 &lt;-RxODE({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; ## Added modeled bioavaiblity, duration and rate fdepot = 1; durDepot = 8; rateDepot = 1250; C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; f(depot) = fdepot dur(depot) = durDepot rate(depot) = rateDepot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }) 8.1 Adding doses to the event table Once created you can add dosing to the event table by the add.dosing(), and et() functions. Using the add.dosing() function you have: argument meaning dose dose amount nbr.doses Number of doses; Should be at least 1. dosing.interval Dosing interval; By default this is 24. dosing.to Compartment where dose is administered. rate Infusion rate start.time The start time of the dose ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hr&quot;) ## The methods ar attached to the event table, so you can use ## them directly ev$add.dosing(dose=10000, nbr.doses = 3)# loading doses ## Starts at time 0; Default dosing interval is 24 ## You can also pipe the event tables to these methods. ev &lt;- ev %&gt;% add.dosing(dose=5000, nbr.doses=14, dosing.interval=12)# maintenance ev #&gt; ───────────────── EventTable with 2 records ──────────────── #&gt; #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 2 x 5 #&gt; time amt ii addl evid #&gt; [h] [mg] [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 10000 24 2 1:Dose (Add) #&gt; 2 0 5000 12 13 1:Dose (Add) Notice that the units were specified in the table. When specified, the units use the units package to keep track of the units and convert them if needed. Additionally, ggforce uses them to label the ggplot axes. The set_units and drop_units are useful to set and drop the RxODE event table units. In this example, you can see the time axes is labeled: rxSolve(m1, ev) %&gt;% plot(C2) If you are more familiar with the NONMEM/RxODE event records, you can also specify dosing using et with the dose elements directly: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) # loading doses ev #&gt; ───────────────── EventTable with 1 records ──────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 1 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 10000 12 6 1:Dose (Add) Which gives: rxSolve(m1, ev) %&gt;% plot(C2) This shows how easy creating event tables can be. 8.2 Adding sampling to an event table If you notice in the above examples, RxODE generated some default sampling times since there was not any sampling times. If you wish more control over the sampling time, you should add the samples to the RxODE event table by add.sampling or et ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hr&quot;) ## The methods ar attached to the event table, so you can use them ## directly ev$add.dosing(dose=10000, nbr.doses = 3)# loading doses ev$add.sampling(seq(0,24,by=4)) ev #&gt; ───────────────── EventTable with 8 records ──────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 7 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 8 x 5 #&gt; time amt ii addl evid #&gt; [h] [mg] [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 24 2 1:Dose (Add) #&gt; 3 4 NA NA NA 0:Observation #&gt; 4 8 NA NA NA 0:Observation #&gt; 5 12 NA NA NA 0:Observation #&gt; 6 16 NA NA NA 0:Observation #&gt; 7 20 NA NA NA 0:Observation #&gt; 8 24 NA NA NA 0:Observation Which gives: solve(m1, ev) %&gt;% plot(C2) Or if you use et you can simply add them in a similar way to add.sampling: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) %&gt;% # loading doses et(seq(0,24,by=4)) ev #&gt; ───────────────── EventTable with 8 records ──────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 7 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 8 x 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 6 1:Dose (Add) #&gt; 3 4 NA NA NA 0:Observation #&gt; 4 8 NA NA NA 0:Observation #&gt; 5 12 NA NA NA 0:Observation #&gt; 6 16 NA NA NA 0:Observation #&gt; 7 20 NA NA NA 0:Observation #&gt; 8 24 NA NA NA 0:Observation which gives the following RxODE solve: solve(m1, ev) %&gt;% plot(C2) Note the jagged nature of these plots since there was only a few sample times. 8.3 Expand the event table to a multi-subject event table. The only thing that is needed to expand an event table is a list of IDs that you want to expand; ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) %&gt;% # loading doses et(seq(0,48,length.out=200)) %&gt;% et(id=1:4) ev #&gt; ──────────────── EventTable with 804 records ─────────────── #&gt; 4 individuals #&gt; 4 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 800 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 804 x 6 #&gt; id time amt ii addl evid #&gt; &lt;int&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 1 0.0000000 NA NA NA 0:Observation #&gt; 2 1 0.0000000 10000 12 6 1:Dose (Add) #&gt; 3 1 0.2412060 NA NA NA 0:Observation #&gt; 4 1 0.4824121 NA NA NA 0:Observation #&gt; 5 1 0.7236181 NA NA NA 0:Observation #&gt; 6 1 0.9648241 NA NA NA 0:Observation #&gt; 7 1 1.2060302 NA NA NA 0:Observation #&gt; 8 1 1.4472362 NA NA NA 0:Observation #&gt; 9 1 1.6884422 NA NA NA 0:Observation #&gt; 10 1 1.9296482 NA NA NA 0:Observation #&gt; # … with 794 more rows You can see in the following simulation there are 4 individuals that are solved for: set.seed(42) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) #&gt; Warning: &#39;ID&#39; missing in &#39;parameters&#39; dataset #&gt; individual parameters are assumed to have the same order as the event dataset 8.4 Add doses and samples within a sampling window In addition to adding fixed doses and fixed sampling times, you can have windows where you sample and draw doses from. For dosing windows you specify the time as an ordered numerical vector with the lowest dosing time and the highest dosing time inside a list. In this example, you start with a dosing time with a 6 hour dosing window: set.seed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,6)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) ev #&gt; ──────────────── EventTable with 16 records ──────────────── #&gt; 4 individuals #&gt; 16 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 16 x 6 #&gt; id low time high amt evid #&gt; &lt;int&gt; [h] [h] [h] &lt;dbl&gt; &lt;evid&gt; #&gt; 1 1 0 5.4888363 6 10000 1:Dose (Add) #&gt; 2 1 12 16.9826858 18 10000 1:Dose (Add) #&gt; 3 1 24 25.7168372 30 10000 1:Dose (Add) #&gt; 4 1 36 41.6224525 42 10000 1:Dose (Add) #&gt; 5 2 0 4.3146735 6 10000 1:Dose (Add) #&gt; 6 2 12 14.7464507 18 10000 1:Dose (Add) #&gt; 7 2 24 28.2303887 30 10000 1:Dose (Add) #&gt; 8 2 36 39.9419537 42 10000 1:Dose (Add) #&gt; 9 3 0 0.8079996 6 10000 1:Dose (Add) #&gt; 10 3 12 16.4195299 18 10000 1:Dose (Add) #&gt; 11 3 24 27.1145757 30 10000 1:Dose (Add) #&gt; 12 3 36 39.8504731 42 10000 1:Dose (Add) #&gt; 13 4 0 4.9826858 6 10000 1:Dose (Add) #&gt; 14 4 12 13.7168372 18 10000 1:Dose (Add) #&gt; 15 4 24 29.6224525 30 10000 1:Dose (Add) #&gt; 16 4 36 41.4888363 42 10000 1:Dose (Add) You can clearly see different dosing times in the following simulation: ev &lt;- ev %&gt;% et(seq(0,48,length.out=200)) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) #&gt; Warning: &#39;ID&#39; missing in &#39;parameters&#39; dataset #&gt; individual parameters are assumed to have the same order as the event dataset Of course in reality the dosing interval may only be 2 hours: set.seed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,2)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) %&gt;% et(seq(0,48,length.out=200)) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) #&gt; Warning: &#39;ID&#39; missing in &#39;parameters&#39; dataset #&gt; individual parameters are assumed to have the same order as the event dataset The same sort of thing can be specified with sampling times. To specify the sampling times in terms of a sampling window, you can create a list of the sampling times. Each sampling time will be a two element ordered numeric vector. set.seed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,2)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) ## Create 20 samples in the first 24 hours and 20 samples in the ## second 24 hours samples &lt;- c(lapply(1:20, function(...){c(0,24)}), lapply(1:20, function(...){c(20,48)})) ## Add the random collection to the event table ev &lt;- ev %&gt;% et(samples) library(ggplot2) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) + geom_point() #&gt; Warning: &#39;ID&#39; missing in &#39;parameters&#39; dataset #&gt; individual parameters are assumed to have the same order as the event dataset This shows the flexibility in dosing and sampling that the RxODE event tables allow. 8.5 Combining event tables Since you can create dosing records and sampling records, you can create any complex dosing regimen you wish. In addition, RxODE allows you to combine event tables by c, seq, rep, and rbind. 8.6 Sequencing event tables One way to combine event table is to sequence them by c, seq or etSeq. This takes the two dosing groups and adds at least one inter-dose interval between them: ## bid for 5 days bid &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000,ii=12,until=set_units(5, &quot;days&quot;)) ## qd for 5 days qd &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=20000,ii=24,until=set_units(5, &quot;days&quot;)) ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) When sequencing events, you can also separate this sequence by a period of time; For example if you wanted to separate this by a week, you could easily do that with the following sequence of event tables: ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,set_units(1, &quot;week&quot;), qd) %&gt;% et(seq(0,18*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) Note that in this example the time between the bid and the qd event tables is exactly one week, not 1 week plus 24 hours because of the inter-dose interval. If you want that behavior, you can sequence it using the wait=\"+ii\". ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,set_units(1, &quot;week&quot;), qd,wait=&quot;+ii&quot;) %&gt;% et(seq(0,18*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) Also note, that RxODE assumes that the dosing is what you want to space the event tables by, and clears out any sampling records when you combine the event tables. If that is not true, you can also use the option samples=\"use\" 8.7 Repeating event tables You can have an event table that you can repeat with etRep or rep. For example 4 rounds of 2 weeks on QD therapy and 1 week off of therapy can be simply specified: qd &lt;-et(timeUnits = &quot;hr&quot;) %&gt;% et(amt=10000, ii=24, until=set_units(2, &quot;weeks&quot;), cmt=&quot;depot&quot;) et &lt;- rep(qd, times=4, wait=set_units(1,&quot;weeks&quot;)) %&gt;% add.sampling(set_units(seq(0, 12.5,by=0.005),weeks)) rxSolve(m1, et) %&gt;% plot(C2) This is a simplified way to use a sequence of event tables. Therefore, many of the same options still apply; That is samples are cleared unless you use samples=\"use\", and the time between event tables is at least the inter-dose interval. You can adjust the timing by the wait option. 8.8 Combining event tables with rbind You may combine event tables with rbind. This does not consider the event times when combining the event tables, but keeps them the same times. If you space the event tables by a waiting period, it also does not consider the inter-dose interval. Using the previous seq you can clearly see the difference. Here was the sequence: ## bid for 5 days bid &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000,ii=12,until=set_units(5, &quot;days&quot;)) ## qd for 5 days qd &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=20000,ii=24,until=set_units(5, &quot;days&quot;)) et &lt;- seq(bid,qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) But if you bind them together with rbind ## bid for 5 days et &lt;- rbind(bid,qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) Still the waiting period applies (but does not consider the inter-dose interval) et &lt;- rbind(bid,wait=set_units(10,days),qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) You can also bind the tables together and make each ID in the event table unique; This can be good to combine cohorts with different expected dosing and sampling times. This requires the id=\"unique\" option; Using the first example shows how this is different in this case: ## bid for 5 days et &lt;- etRbind(bid,qd, id=&quot;unique&quot;) %&gt;% et(seq(0,150,length.out=500)); library(ggplot2) rxSolve(m1, et) %&gt;% plot(C2) + facet_wrap( ~ id) 8.9 Expanding events Event tables can be expanded so they contain an addl data item, like the following example: ev &lt;- et() %&gt;% et(dose=50, ii=8, until=48) ev #&gt; ───────────────── EventTable with 1 records ──────────────── #&gt; #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); or etExpand(x) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 1 x 5 #&gt; time amt ii addl evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;evid&gt; #&gt; 1 0 50 8 6 1:Dose (Add) You can expand the events so they do not have the addl items by $expand() or etExpand(ev): The first, etExpand(ev) expands the event table without modifying the original data frame: etExpand(ev) #&gt; ───────────────── EventTable with 7 records ──────────────── #&gt; #&gt; 7 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 7 x 4 #&gt; time amt ii evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;evid&gt; #&gt; 1 0 50 0 1:Dose (Add) #&gt; 2 8 50 0 1:Dose (Add) #&gt; 3 16 50 0 1:Dose (Add) #&gt; 4 24 50 0 1:Dose (Add) #&gt; 5 32 50 0 1:Dose (Add) #&gt; 6 40 50 0 1:Dose (Add) #&gt; 7 48 50 0 1:Dose (Add) You can see the addl events were expanded, however the original data frame remained intact: print(ev) #&gt; ───────────────── EventTable with 1 records ──────────────── #&gt; #&gt; 1 dosing records (see $get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see $get.sampling(); add with add.sampling or et) #&gt; multiple doses in `addl` columns, expand with $expand(); or etExpand() #&gt; ── First part of : ───────────────────────────────────────── #&gt; # A tibble: 1 x 5 #&gt; time amt ii addl evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;evid&gt; #&gt; 1 0 50 8 6 1:Dose (Add) If you use ev$expand() it will modify the ev object. This is similar to an object-oriented method: ev$expand() ev #&gt; ───────────────── EventTable with 7 records ──────────────── #&gt; #&gt; 7 dosing records (see x$get.dosing(); add with add.dosing or et) #&gt; 0 observation times (see x$get.sampling(); add with add.sampling or et) #&gt; ── First part of x: ──────────────────────────────────────── #&gt; # A tibble: 7 x 4 #&gt; time amt ii evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;evid&gt; #&gt; 1 0 50 0 1:Dose (Add) #&gt; 2 8 50 0 1:Dose (Add) #&gt; 3 16 50 0 1:Dose (Add) #&gt; 4 24 50 0 1:Dose (Add) #&gt; 5 32 50 0 1:Dose (Add) #&gt; 6 40 50 0 1:Dose (Add) #&gt; 7 48 50 0 1:Dose (Add) 8.10 Event tables in Rstudio Notebooks In addition to the output in the console which has been shown in the above examples, Rstudio notebook output is different and can be seen in the following screenshots; The first screenshot shows how the event table looks after evaluating it in the Rstduio notebook This is a simple dataframe that allows you to page through the contents. If you click on the first box in the Rstudio notebook output, it will have the notes about the event table: "],["solve.html", "Chapter 9 Solving and solving options 9.1 General Solving Options 9.2 lsoda/dop solving options 9.3 Inductive Linerization Options 9.4 Steady State Solving Options 9.5 RxODE numeric stability options 9.6 Linear compartment model sensitivity options 9.7 Covariate Solving Options 9.8 Simulation options 9.9 RxODE output options 9.10 Internal RxODE options 9.11 Parallel/Threaded Solve", " Chapter 9 Solving and solving options In general, ODEs are solved using a combination of: A compiled model specification from RxODE(), specified with object= Input parameters, specified with params= (and could be blank) Input data or event table, specified with events= Initial conditions, specified by inits= (and possibly in the model itself by state(0)=) The solving options are given in the sections below: 9.1 General Solving Options 9.1.1 object object is a either a RxODE family of objects, or a file-name with a RxODE model specification, or a string with a RxODE model specification. 9.1.2 params params a numeric named vector with values for every parameter in the ODE system; the names must correspond to the parameter identifiers used in the ODE specification; 9.1.3 events events an eventTable object describing the input (e.g., doses) to the dynamic system and observation sampling time points (see [eventTable()]); 9.1.4 inits inits a vector of initial values of the state variables (e.g., amounts in each compartment), and the order in this vector must be the same as the state variables (e.g., PK/PD compartments); 9.1.5 method method The method for solving ODEs. Currently this supports: \"liblsoda\" thread safe lsoda. This supports parallel thread-based solving, and ignores user Jacobian specification. \"lsoda\" – LSODA solver. Does not support parallel thread-based solving, but allows user Jacobian specification. \"dop853\" – DOP853 solver. Does not support parallel thread-based solving nor user Jacobain specification \"indLin\" – Solving through inductive linearization. The RxODE dll must be setup specially to use this solving routine. 9.1.6 stiff stiff a logical (TRUE by default) indicating whether the ODE system is stiff or not. For stiff ODE systems (stiff = TRUE), RxODE uses the LSODA (Livermore Solver for Ordinary Differential Equations) Fortran package, which implements an automatic method switching for stiff and non-stiff problems along the integration interval, authored by Hindmarsh and Petzold (2003). For non-stiff systems (stiff = FALSE), RxODE uses DOP853, an explicit Runge-Kutta method of order 8(5, 3) of Dormand and Prince as implemented in C by Hairer and Wanner (1993). If stiff is not specified, the method argument is used instead. 9.2 lsoda/dop solving options 9.2.1 atol atol a numeric absolute tolerance (1e-8 by default) used by the ODE solver to determine if a good solution has been achieved; This is also used in the solved linear model to check if prior doses do not add anything to the solution. 9.2.2 rtol rtol a numeric relative tolerance (1e-6 by default) used by the ODE solver to determine if a good solution has been achieved. This is also used in the solved linear model to check if prior doses do not add anything to the solution. 9.2.3 maxsteps maxsteps maximum number of (internally defined) steps allowed during one call to the solver. (5000 by default) 9.2.4 hmin hmin The minimum absolute step size allowed. The default value is 0. 9.2.5 hmax hmax The maximum absolute step size allowed. When hmax=NA (default), uses the average difference + hmaxSd*sd in times and sampling events. The hmaxSd is a user specified parameter and which defaults to zero. When hmax=NULL RxODE uses the maximum difference in times in your sampling and events. The value 0 is equivalent to infinite maximum absolute step size. 9.2.6 hmaxSd hmaxSd The number of standard deviations of the time difference to add to hmax. The default is 0 9.2.7 hini hini The step size to be attempted on the first step. The default value is determined by the solver (when hini = 0) 9.2.8 maxordn maxordn The maximum order to be allowed for the nonstiff (Adams) method. The default is 12. It can be between 1 and 12. 9.2.9 maxords maxords The maximum order to be allowed for the stiff (BDF) method. The default value is 5. This can be between 1 and 5. 9.2.10 mxhnil mxhnil maximum number of messages printed (per problem) warning that T + H = T on a step (H = step size). This must be positive to result in a non-default value. The default value is 0 (or infinite). 9.2.11 hmxi hmxi inverse of the maximum absolute value of H to are used. hmxi = 0.0 is allowed and corresponds to an infinite hmax1 (default).hminandhmximay be changed at any time, but will not take effect until the next change ofHis considered. This option is only considered withmethod=“liblsoda”`. 9.2.12 istateReset istateReset When TRUE, reset the ISTATE variable to 1 for lsoda and liblsoda with doses, like deSolve; When FALSE, do not reset the ISTATE variable with doses. 9.3 Inductive Linerization Options 9.3.1 indLinMatExpType indLinMatExpType This is them matrix exponential type that is use for RxODE. Currently the following are supported: Al-Mohy Uses the exponential matrix method of Al-Mohy Higham (2009) arma Use the exponential matrix from RcppArmadillo expokit Use the exponential matrix from Roger B. Sidje (1998) 9.3.2 indLinMatExpOrder indLinMatExpOrder an integer, the order of approximation to be used, for the Al-Mohy and expokit values. The best value for this depends on machine precision (and slightly on the matrix). We use 6 as a default. 9.3.3 indLinPhiTol indLinPhiTol the requested accuracy tolerance on exponential matrix. 9.3.4 indLinPhiM indLinPhiM the maximum size for the Krylov basis 9.4 Steady State Solving Options 9.4.1 minSS minSS Minimum number of iterations for a steady-state dose 9.4.2 maxSS maxSS Maximum number of iterations for a steady-state dose 9.4.3 strictSS strictSS Boolean indicating if a strict steady-state is required. If a strict steady-state is (TRUE) required then at least minSS doses are administered and the total number of steady states doses will continue until maxSS is reached, or atol and rtol for every compartment have been reached. However, if ODE solving problems occur after the minSS has been reached the whole subject is considered an invalid solve. If strictSS is FALSE then as long as minSS has been reached the last good solve before ODE solving problems occur is considered the steady state, even though either atol, rtol or maxSS have not been achieved. 9.4.4 infSSstep infSSstep Step size for determining if a constant infusion has reached steady state. By default this is large value, 420. 9.4.5 ssAtol ssAtol Steady state atol convergence factor. Can be a vector based on each state. 9.4.6 ssRtol ssRtol Steady state rtol convergence factor. Can be a vector based on each state. 9.5 RxODE numeric stability options 9.5.1 maxAtolRtolFactor maxAtolRtolFactor The maximum atol/rtol that FOCEi and other routines may adjust to. By default 0.1 9.5.2 stateTrim stateTrim When amounts/concentrations in one of the states are above this value, trim them to be this value. By default Inf. Also trims to -stateTrim for large negative amounts/concentrations. If you want to trim between a range say c(0, 2000000) you may specify 2 values with a lower and upper range to make sure all state values are in the reasonable range. 9.5.3 safeZero safeZero Use safe zero divide and log routines. By default this is turned on but you may turn it off if you wish. 9.5.4 sumType sumType Sum type to use for sum() in RxODE code blocks. pairwise uses the pairwise sum (fast, default) fsum uses Python’s fsum function (most accurate) kahan uses Kahan correction neumaier uses Neumaier correction c uses no correction: default/native summing 9.5.5 prodType prodType Product to use for prod() in RxODE blocks long double converts to long double, performs the multiplication and then converts back. double uses the standard double scale for multiplication. 9.5.6 maxwhile maxwhile represents the maximum times a while loop is evaluated before exiting. By default this is 100000 9.5.7 transitAbs transitAbs boolean indicating if this is a transit compartment absorption 9.6 Linear compartment model sensitivity options 9.6.1 sensType sensType Sensitivity type for linCmt() model: advan Use the direct advan solutions autodiff Use the autodiff advan solutions forward Use forward difference solutions central Use central differences 9.6.2 linDiff linDiff This gives the linear difference amount for all the types of linear compartment model parameters where sensitivities are not calculated. The named components of this numeric vector are: \"lag\" Central compartment lag \"f\" Central compartment bioavailability \"rate\" Central compartment modeled rate \"dur\" Central compartment modeled duration \"lag2\" Depot compartment lag \"f2\" Depot compartment bioavailability \"rate2\" Depot compartment modeled rate \"dur2\" Depot compartment modeled duration 9.6.3 linDiffCentral linDiffCentral This gives the which parameters use central differences for the linear compartment model parameters. The are the same components as linDiff 9.7 Covariate Solving Options 9.7.1 iCov iCov A data frame of individual non-time varying covariates to combine with the params to form a parameter data.frame. 9.7.2 covsInterpolation covsInterpolation specifies the interpolation method for time-varying covariates. When solving ODEs it often samples times outside the sampling time specified in events. When this happens, the time varying covariates are interpolated. Currently this can be: \"linear\" interpolation, which interpolates the covariate by solving the line between the observed covariates and extrapolating the new covariate value. \"constant\" – Last observation carried forward (the default). \"NOCB\" – Next Observation Carried Backward. This is the same method that NONMEM uses. \"midpoint\" Last observation carried forward to midpoint; Next observation carried backward to midpoint. 9.7.3 addCov addCov A boolean indicating if covariates should be added to the output matrix or data frame. By default this is disabled. 9.8 Simulation options 9.8.1 seed seed an object specifying if and how the random number generator should be initialized 9.8.2 nsim nsim represents the number of simulations. For RxODE, if you supply single subject event tables (created with [eventTable()]) 9.8.3 thetaMat thetaMat Named theta matrix. 9.8.4 thetaLower thetaLower Lower bounds for simulated population parameter variability (by default -Inf) 9.8.5 thetaUpper thetaUpper Upper bounds for simulated population unexplained variability (by default Inf) 9.8.6 thetaDf thetaDf The degrees of freedom of a t-distribution for simulation. By default this is NULL which is equivalent to Inf degrees, or to simulate from a normal distribution instead of a t-distribution. 9.8.7 thetaIsChol thetaIsChol Indicates if the theta supplied is a Cholesky decomposed matrix instead of the traditional symmetric matrix. 9.8.8 nStud nStud Number virtual studies to characterize uncertainty in estimated parameters. 9.8.9 omega omega Estimate of Covariance matrix. When omega is a list, assume it is a block matrix and convert it to a full matrix for simulations. 9.8.10 omegaIsChol omegaIsChol Indicates if the omega supplied is a Cholesky decomposed matrix instead of the traditional symmetric matrix. 9.8.11 omegaSeparation omegaSeparation Omega separation strategy Tells the type of separation strategy when simulating covariance with parameter uncertainty with standard deviations modeled in the thetaMat matrix. \"lkj\" simulates the correlation matrix from the rLKJ1 matrix with the distribution parameter eta equal to the degrees of freedom nu by (nu-1)/2 \"separation\" simulates from the identity inverse Wishart covariance matrix with nu degrees of freedom. This is then converted to a covariance matrix and augmented with the modeled standard deviations. While computationally more complex than the \"lkj\" prior, it performs better when the covariance matrix size is greater or equal to 10 \"auto\" chooses \"lkj\" when the dimension of the matrix is less than 10 and \"separation\" when greater than equal to 10. 9.8.12 omegaXform omegaXform When taking omega values from the thetaMat simulations (using the separation strategy for covariance simulation), how should the thetaMat values be turned int standard deviation values: identity This is when standard deviation values are directly modeled by the params and thetaMat matrix variance This is when the params and thetaMat simulates the variance that are directly modeled by the thetaMat matrix log This is when the params and thetaMat simulates log(sd) nlmixrSqrt This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the x^2 modeled along the diagonal. This only works with a diagonal matrix. nlmixrLog This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the exp(x^2) along the diagonal. This only works with a diagonal matrix. nlmixrIdentity This is when the params and thetaMat simulates the inverse cholesky decomposed matrix. This only works with a diagonal matrix. 9.8.13 omegaLower omegaLower Lower bounds for simulated ETAs (by default -Inf) 9.8.14 omegaUpper omegaUpper Upper bounds for simulated ETAs (by default Inf) 9.8.15 omegaDf omegaDf The degrees of freedom of a t-distribution for simulation. By default this is NULL which is equivalent to Inf degrees, or to simulate from a normal distribution instead of a t-distribution. 9.8.16 nSub nSub Number between subject variabilities (ETAs) simulated for every realization of the parameters. 9.8.17 dfSub dfSub Degrees of freedom to sample the between subject variability matrix from the inverse Wishart distribution (scaled) or scaled inverse chi squared distribution. 9.8.18 sigma sigma Named sigma covariance or Cholesky decomposition of a covariance matrix. The names of the columns indicate parameters that are simulated. These are simulated for every observation in the solved system. 9.8.19 sigmaLower sigmaLower Lower bounds for simulated unexplained variability (by default -Inf) 9.8.20 sigmaUpper sigmaUpper Upper bounds for simulated unexplained variability (by default Inf) 9.8.21 sigmaXform sigmaXform When taking sigma values from the thetaMat simulations (using the separation strategy for covariance simulation), how should the thetaMat values be turned int standard deviation values: identity This is when standard deviation values are directly modeled by the params and thetaMat matrix variance This is when the params and thetaMat simulates the variance that are directly modeled by the thetaMat matrix log This is when the params and thetaMat simulates log(sd) nlmixrSqrt This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the x^2 modeled along the diagonal. This only works with a diagonal matrix. nlmixrLog This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the exp(x^2) along the diagonal. This only works with a diagonal matrix. nlmixrIdentity This is when the params and thetaMat simulates the inverse cholesky decomposed matrix. This only works with a diagonal matrix. 9.8.22 sigmaDf sigmaDf Degrees of freedom of the sigma t-distribution. By default it is equivalent to Inf, or a normal distribution. 9.8.23 sigmaIsChol sigmaIsChol Boolean indicating if the sigma is in the Cholesky decomposition instead of a symmetric covariance 9.8.24 sigmaSeparation sigmaSeparation separation strategy for sigma; Tells the type of separation strategy when simulating covariance with parameter uncertainty with standard deviations modeled in the thetaMat matrix. \"lkj\" simulates the correlation matrix from the rLKJ1 matrix with the distribution parameter eta equal to the degrees of freedom nu by (nu-1)/2 \"separation\" simulates from the identity inverse Wishart covariance matrix with nu degrees of freedom. This is then converted to a covariance matrix and augmented with the modeled standard deviations. While computationally more complex than the \"lkj\" prior, it performs better when the covariance matrix size is greater or equal to 10 \"auto\" chooses \"lkj\" when the dimension of the matrix is less than 10 and \"separation\" when greater than equal to 10. 9.8.25 dfObs dfObs Degrees of freedom to sample the unexplained variability matrix from the inverse Wishart distribution (scaled) or scaled inverse chi squared distribution. 9.8.26 resample resample A character vector of model variables to resample from the input dataset; This sampling is done with replacement. When NULL or FALSE no resampling is done. When TRUE resampling is done on all covariates in the input dataset 9.8.27 resampleID resampleID boolean representing if the resampling should be done on an individual basis TRUE (ie. a whole patient is selected) or each covariate is resampled independent of the subject identifier FALSE. When resampleID=TRUE correlations of parameters are retained, where as when resampleID=FALSE ignores patient covariate correaltions. Hence the default is resampleID=TRUE. 9.9 RxODE output options 9.9.1 returnType returnType This tells what type of object is returned. The currently supported types are: \"rxSolve\" (default) will return a reactive data frame that can change easily change different pieces of the solve and update the data frame. This is the currently standard solving method in RxODE, is used for rxSolve(object, ...), solve(object,...), \"data.frame\" – returns a plain, non-reactive data frame; Currently very slightly faster than returnType=\"matrix\" \"matrix\" – returns a plain matrix with column names attached to the solved object. This is what is used object$run as well as object$solve \"data.table\" – returns a data.table; The data.table is created by reference (ie setDt()), which should be fast. \"tbl\" or \"tibble\" returns a tibble format. 9.9.2 addDosing addDosing Boolean indicating if the solve should add RxODE EVID and related columns. This will also include dosing information and estimates at the doses. Be default, RxODE only includes estimates at the observations. (default FALSE). When addDosing is NULL, only include EVID=0 on solve and exclude any model-times or EVID=2. If addDosing is NA the classic RxODE EVID events are returned. When addDosing is TRUE add the event information in NONMEM-style format; If subsetNonmem=FALSE RxODE will also include extra event types (EVID) for ending infusion and modeled times: EVID=-1 when the modeled rate infusions are turned off (matches rate=-1) EVID=-2 When the modeled duration infusions are turned off (matches rate=-2) EVID=-10 When the specified rate infusions are turned off (matches rate&gt;0) EVID=-20 When the specified dur infusions are turned off (matches dur&gt;0) EVID=101,102,103,... Modeled time where 101 is the first model time, 102 is the second etc. 9.9.3 keep keep Columns to keep from either the input dataset or the iCov dataset. With the iCov dataset, the column is kept once per line. For the input dataset, if any records are added to the data LOCF (Last Observation Carried forward) imputation is performed. 9.9.4 drop drop Columns to drop from the output 9.9.5 idFactor idFactor This boolean indicates if original ID values should be maintained. This changes the default sequentially ordered ID to a factor with the original ID values in the original dataset. By default this is enabled. 9.9.6 subsetNonmem subsetNonmem subset to NONMEM compatible EVIDs only. By default TRUE. 9.9.7 matrix matrix A boolean indicating if a matrix should be returned instead of the RxODE’s solved object. 9.9.8 scale scale a numeric named vector with scaling for ode parameters of the system. The names must correspond to the parameter identifiers in the ODE specification. Each of the ODE variables will be divided by the scaling factor. For example scale=c(center=2) will divide the center ODE variable by 2. 9.9.9 amountUnits amountUnits This supplies the dose units of a data frame supplied instead of an event table. This is for importing the data as an RxODE event table. 9.9.10 timeUnits timeUnits This supplies the time units of a data frame supplied instead of an event table. This is for importing the data as an RxODE event table. 9.9.11 theta theta A vector of parameters that will be named THETA\\[#\\] and added to parameters 9.9.12 eta eta A vector of parameters that will be named ETA\\[#\\] and added to parameters 9.9.13 from from When there is no observations in the event table, start observations at this value. By default this is zero. 9.9.14 to to When there is no observations in the event table, end observations at this value. By default this is 24 + maximum dose time. 9.9.15 length.out length.out The number of observations to create if there isn’t any observations in the event table. By default this is 200. 9.9.16 by by When there are no observations in the event table, this is the amount to increment for the observations between from and to. 9.9.17 warnIdSort warnIdSort Warn if the ID is not present and RxODE assumes the order of the parameters/iCov are the same as the order of the parameters in the input dataset. 9.9.18 warnDrop warnDrop Warn if column(s) were supposed to be dropped, but were not present. 9.10 Internal RxODE options 9.10.1 nDisplayProgress nDisplayProgress An integer indicating the minimum number of c-based solves before a progress bar is shown. By default this is 10,000. 9.10.2 … ... Other arguments including scaling factors for each compartment. This includes S# = numeric will scale a compartment # by a dividing the compartment amount by the scale factor, like NONMEM. 9.10.3 a a when using solve(), this is equivalent to the object argument. If you specify object later in the argument list it overwrites this parameter. 9.10.4 b b when using solve(), this is equivalent to the params argument. If you specify params as a named argument, this overwrites the output 9.10.5 updateObject updateObject This is an internally used flag to update the RxODE solved object (when supplying an RxODE solved object) as well as returning a new object. You probably should not modify it’s FALSE default unless you are willing to have unexpected results. 9.11 Parallel/Threaded Solve 9.11.1 cores cores Number of cores used in parallel ODE solving. This is equivalent to calling [setRxThreads()] 9.11.2 nCoresRV nCoresRV Number of cores used for the simulation of the sigma variables. By default this is 1. To reproduce the results you need to run on the same platform with the same number of cores. This is the reason this is set to be one, regardless of what the number of cores are used in threaded ODE solving. "],["output.html", "Chapter 10 RxODE output 10.1 Using RxODE data frames 10.2 Updating the data-set interactively", " Chapter 10 RxODE output 10.1 Using RxODE data frames 10.1.1 Creating an interactive data frame RxODE supports returning a solved object that is a modified data-frame. This is done by the predict(), solve(), or rxSolve() methods. library(RxODE) library(units) ### Setup example model mod1 &lt;-RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) ### Seup parameters and initial conditions theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects inits &lt;- c(eff=1) ### Setup dosing event information ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% add.sampling(0:240); ### Now solve x &lt;- predict(mod1,theta, ev, inits) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ or x &lt;- solve(mod1,theta, ev, inits) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Or with mattigr x &lt;- mod1 %&gt;% solve(theta, ev, inits) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ 10.1.2 RxODE solved object properties 10.1.3 Using the solved object as a simple data frame The solved object acts as a data.frame or tbl that can be filtered by dpylr. For example you could filter it easily. library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union ### You can drop units for comparisons and filtering x &lt;- mod1 %&gt;% solve(theta,ev,inits) %&gt;% drop_units %&gt;% filter(time &lt;= 3) %&gt;% as.tbl #&gt; Warning: `as.tbl()` was deprecated in dplyr 1.0.0. #&gt; Please use `tibble::as_tibble()` instead. ### or keep them and compare with the proper units. x &lt;- mod1 %&gt;% solve(theta,ev,inits) %&gt;% filter(time &lt;= set_units(3, hr)) %&gt;% as.tbl x #&gt; # A tibble: 4 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 10.2 Updating the data-set interactively However it isn’t just a simple data object. You can use the solved object to update parameters on the fly, or even change the sampling time. First we need to recreate the original solved system: x &lt;- mod1 %&gt;% solve(theta,ev,inits); print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ 10.2.1 Modifying initial conditions To examine or change initial conditions, you can use the syntax cmt.0, cmt0, or cmt_0. In the case of the eff compartment defined by the model, this is: x$eff0 #&gt; [1] 1 which shows the initial condition of the effect compartment. If you wished to change this initial condition to 2, this can be done easily by: x$eff0 &lt;- 2 print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 2 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 2 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.50 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.37 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.31 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.27 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.23 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ plot(x) 10.2.2 Modifying observation times for RxODE Notice that the initial effect is now 2. You can also change the sampling times easily by this method by changing t or time. For example: x$t &lt;- seq(0,5,length.out=20) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 2 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 20 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0000000 0 0 10000 0 0 2 #&gt; 2 0.2631579 16.8 0.0817 9255. 677. 24.3 1.79 #&gt; 3 0.5263158 29.5 0.299 8566. 1187. 88.7 1.65 #&gt; 4 0.7894737 38.9 0.615 7929. 1562. 183. 1.55 #&gt; 5 1.0526316 45.5 1.00 7338. 1830. 298. 1.49 #&gt; 6 1.3157895 50.1 1.44 6792. 2013. 427. 1.44 #&gt; # … with 14 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ plot(x) 10.2.3 Modifying simulation parameters You can also access or change parameters by the $ operator. For example, accessing KA can be done by: x$KA #&gt; [1] 0.294 And you may change it by assigning it to a new value. x$KA &lt;- 1 print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.2 297.0 1.0 18.6 10.5 1.0 1.0 200.0 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 2 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 20 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0000000 0 0 10000 0 0 2 #&gt; 2 0.2631579 52.2 0.261 7686. 2098. 77.6 1.82 #&gt; 3 0.5263158 83.3 0.900 5908. 3348. 267. 1.74 #&gt; 4 0.7894737 99.8 1.75 4541. 4010. 519. 1.69 #&gt; 5 1.0526316 106. 2.69 3490. 4273. 800. 1.67 #&gt; 6 1.3157895 106. 3.66 2683. 4272. 1086. 1.64 #&gt; # … with 14 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ plot(x) You can access/change all the parameters, initialization(s) or events with the $params, $inits, $events accessor syntax, similar to what is used above. This syntax makes it easy to update and explore the effect of various parameters on the solved object. "],["simulation.html", "Chapter 11 Simulation 11.1 Single Subject solving 11.2 Population Simulations with RxODE 11.3 Simulation of Clinical Trials 11.4 Using prior data for solving", " Chapter 11 Simulation 11.1 Single Subject solving Originally, RxODE was only created to solve ODEs for one individual. That is a single system without any changes in individual parameters. Of course this is still supported, the classic examples are found in RxODE intro. This article discusses the differences between multiple subject and single subject solving. There are three differences: Single solving does not solve each ID in parallel Single solving lacks the id column in parameters($params) as well as in the actual dataset. Single solving allows parameter exploration easier because each parameter can be modified. With multiple subject solves, you have to make sure to update each individual parameter. The first obvious difference is in speed; With multiple subjects you can run each subject ID in parallel. For more information and examples of the speed gains with multiple subject solving see the Speeding up RxODE vignette. The next difference is the amount of information output in the final data. Taking the 2 compartment indirect response model originally in the tutorial: library(RxODE) mod1 &lt;-RxODE({ KA=2.94E-01 CL=1.86E+01 V2=4.02E+01 Q=1.05E+01 V3=2.97E+02 Kin=1 Kout=1 EC50=200 C2 = centr/V2 C3 = peri/V3 d/dt(depot) =-KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) = 1 }) et &lt;- et(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) %&gt;% et(dose=10000, addl=9, ii=12) %&gt;% et(amt=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% et(0:240) # sampling Now a simple solve x &lt;- rxSolve(mod1, et) x #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters (x$params): ────────────────────────────────── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ─────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ plot(x, C2, eff) To better see the differences between the single solve, you can solve for 2 individuals x2 &lt;- rxSolve(mod1, et %&gt;% et(id=1:2), params=data.frame(CL=c(18.6, 7.6))) #&gt; Warning: &#39;ID&#39; missing in &#39;parameters&#39; dataset #&gt; individual parameters are assumed to have the same order as the event dataset print(x2) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; # A tibble: 2 x 9 #&gt; id KA CL V2 Q V3 Kin Kout EC50 #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.294 18.6 40.2 10.5 297 1 1 200 #&gt; 2 2 0.294 7.6 40.2 10.5 297 1 1 200 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 482 x 8 #&gt; id time C2 C3 depot centr peri eff #&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0 0 10000 0 0 1 #&gt; 2 1 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 1 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 1 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 1 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 1 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 476 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ plot(x2, C2, eff) By observing the two solves, you can see: A multiple subject solve contains the id column both in the data frame and then data frame of parameters for each subject. The last feature that is not as obvious, modifying the individual parameters. For single subject data, you can modify the RxODE data frame changing initial conditions and parameter values as if they were part of the data frame, as described in the RxODE Data Frames. For multiple subject solving, this feature still works, but requires care when supplying each individual’s parameter value, otherwise you may change the solve and drop parameter for key individuals. 11.1.1 Summary of Single solve vs Multiple subject solving Feature Single Subject Solve Multiple Subject Solve Parallel None Each Subject $params data.frame with one parameter value data.frame with one parameter per subject (w/ID column) solved data Can modify individual parameters with $ syntax Have to modify all the parameters to update solved object 11.2 Population Simulations with RxODE 11.2.1 Simulation of Variability with RxODE In pharmacometrics the nonlinear-mixed effect modeling software (like nlmixr) characterizes the between-subject variability. With this between subject variability you can simulate new subjects. Assuming that you have a 2-compartment, indirect response model, you can set create an RxODE model describing this system below: 11.2.1.1 Setting up the RxODE model library(RxODE) set.seed(32) mod &lt;- RxODE({ eff(0) = 1 C2 = centr/V2*(1+prop.err); C3 = peri/V3; CL = TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) 11.2.1.2 Adding the parameter estimates The next step is to get the parameters into R so that you can start the simulation: theta &lt;- c(KA=2.94E-01, TCl=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200, prop.err=0) # effects In this case, I use lotri to specify the omega since it uses similar lower-triangular matrix specification as nlmixr (also similar to NONMEM): ### the column names of the omega matrix need to match the parameters specified by RxODE omega &lt;- lotri(eta.Cl ~ 0.4^2) omega #&gt; eta.Cl #&gt; eta.Cl 0.16 11.2.1.3 Simulating The next step to simulate is to create the dosing regimen for overall simulation: ev &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=&quot;centr&quot;) If you wish, you can also add sampling times (though now RxODE can fill these in for you): ev &lt;- ev %&gt;% et(0,48, length.out=100) Note the et takes similar arguments as seq when adding sampling times. There are more methods to adding sampling times and events to make complex dosing regimens (See the event vignette). This includes ways to add variability to the both the sampling and dosing times). Once this is complete you can simulate using the rxSolve routine: sim &lt;- rxSolve(mod,theta,ev,omega=omega,nSub=100) To quickly look and customize your simulation you use the default plot routine. Since this is an RxODE object, it will create a ggplot2 object that you can modify as you wish. The extra parameter to the plot tells RxODE/R what piece of information you are interested in plotting. In this case, we are interested in looking at the derived parameter C2: 11.2.1.4 Checking the simulation with plot library(ggplot2) ### The plots from RxODE are ggplots so they can be modified with ### standard ggplot commands. plot(sim, C2, log=&quot;y&quot;) + ylab(&quot;Central Compartment&quot;) Of course this additional parameter could also be a state value, like eff: ### They also takes many of the standard plot arguments; See ?plot plot(sim, eff, ylab=&quot;Effect&quot;) Or you could even look at the two side-by-side: plot(sim, C2, eff) Or stack them with patchwork library(patchwork) plot(sim, C2, log=&quot;y&quot;) / plot(sim, eff) 11.2.1.5 Processing the data to create summary plots Usually in pharmacometric simulations it is not enough to simply simulate the system. We have to do something easier to digest, like look at the central and extreme tendencies of the simulation. Since the RxODE solve object is a type of data frame It is now straightforward to perform calculations and generate plots with the simulated data. You can Below, the 5th, 50th, and 95th percentiles of the simulated data are plotted. confint(sim, &quot;C2&quot;, level=0.95) %&gt;% plot(ylab=&quot;Central Concentration&quot;, log=&quot;y&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done confint(sim, &quot;eff&quot;, level=0.95) %&gt;% plot(ylab=&quot;Effect&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done Note that you can see the parameters that were simulated for the example head(sim$param) #&gt; sim.id V2 prop.err V3 TCl eta.Cl KA Q Kin Kout EC50 #&gt; 1 1 40.2 0 297 18.6 0.2368417 0.294 10.5 1 1 200 #&gt; 2 2 40.2 0 297 18.6 0.5454099 0.294 10.5 1 1 200 #&gt; 3 3 40.2 0 297 18.6 0.1828379 0.294 10.5 1 1 200 #&gt; 4 4 40.2 0 297 18.6 -0.2237885 0.294 10.5 1 1 200 #&gt; 5 5 40.2 0 297 18.6 0.4640872 0.294 10.5 1 1 200 #&gt; 6 6 40.2 0 297 18.6 -0.2748536 0.294 10.5 1 1 200 11.2.1.6 Simulation of unexplained variability (sigma) In addition to conveniently simulating between subject variability, you can also easily simulate unexplained variability. mod &lt;- RxODE({ eff(0) = 1 C2 = centr/V2; C3 = peri/V3; CL = TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; e = eff+eff.err cp = centr*(1+cp.err) }) theta &lt;- c(KA=2.94E-01, TCl=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects sigma &lt;- lotri(eff.err ~ 0.1, cp.err ~ 0.1) sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma) s &lt;- confint(sim, c(&quot;eff&quot;, &quot;centr&quot;)); #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done plot(s) 11.2.1.7 Simulation of Individuals Sometimes you may want to match the dosing and observations of individuals in a clinical trial. To do this you will have to create a data.frame using the RxODE event specification as well as an ID column to indicate an individual. The RxODE event vignette talks more about how these datasets should be created. library(dplyr) ev1 &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=1, dosing.to=2) %&gt;% add.sampling(seq(0,48,length.out=10)); ev2 &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=5000, nbr.doses=1, dosing.to=2) %&gt;% add.sampling(seq(0,48,length.out=8)); dat &lt;- rbind(data.frame(ID=1, ev1$get.EventTable()), data.frame(ID=2, ev2$get.EventTable())) ### Note the number of subject is not needed since it is determined by the data sim &lt;- rxSolve(mod, theta, dat, omega=omega, sigma=sigma) sim %&gt;% select(id, time, e, cp) #&gt; id time e cp #&gt; 1 1 0.000000 [h] 1.0563542 11329.59098 #&gt; 2 1 5.333333 [h] 1.4003578 376.07820 #&gt; 3 1 10.666667 [h] 0.0510544 117.09167 #&gt; 4 1 16.000000 [h] 1.4589483 141.30089 #&gt; 5 1 21.333333 [h] 1.1416624 84.85403 #&gt; 6 1 26.666667 [h] 1.2504412 95.93320 #&gt; 7 1 32.000000 [h] 0.9425509 144.84771 #&gt; 8 1 37.333333 [h] 1.5173332 148.73731 #&gt; 9 1 42.666667 [h] 1.2391798 60.69626 #&gt; 10 1 48.000000 [h] 1.3173971 53.60546 #&gt; 11 2 0.000000 [h] 0.7351683 5471.03043 #&gt; 12 2 6.857143 [h] 0.7138482 109.19130 #&gt; 13 2 13.714286 [h] 1.2041123 137.81498 #&gt; 14 2 20.571429 [h] 1.1766657 81.08167 #&gt; 15 2 27.428571 [h] 1.7274978 57.74205 #&gt; 16 2 34.285714 [h] 0.4546936 60.74535 #&gt; 17 2 41.142857 [h] 0.7159257 44.59950 #&gt; 18 2 48.000000 [h] 1.3206859 42.03860 11.3 Simulation of Clinical Trials By either using a simple single event table, or data from a clinical trial as described above, a complete clinical trial simulation can be performed. Typically in clinical trial simulations you want to account for the uncertainty in the fixed parameter estimates, and even the uncertainty in both your between subject variability as well as the unexplained variability. RxODE allows you to account for these uncertainties by simulating multiple virtual “studies,” specified by the parameter nStud. Each of these studies samples a realization of fixed effect parameters and covariance matrices for the between subject variability(omega) and unexplained variabilities (sigma). Depending on the information you have from the models, there are a few strategies for simulating a realization of the omega and sigma matrices. The first strategy occurs when either there is not any standard errors for standard deviations (or related parameters), or there is a modeled correlation in the model you are simulating from. In that case the suggested strategy is to use the inverse Wishart (parameterized to scale to the conjugate prior)/scaled inverse chi distribution. this approach uses a single parameter to inform the variability of the covariance matrix sampled (the degrees of freedom). The second strategy occurs if you have standard errors on the variance/standard deviation with no modeled correlations in the covariance matrix. In this approach you perform separate simulations for the standard deviations and the correlation matrix. First you simulate the variance/standard deviation components in the thetaMat multivariate normal simulation. After simulation and transformation to standard deviations, a correlation matrix is simulated using the degrees of freedom of your covariance matrix. Combining the simulated standard deviation with the simulated correlation matrix will give a simulated covariance matrix. For smaller dimension covariance matrices (dimension &lt; 10x10) it is recommended you use the lkj distribution to simulate the correlation matrix. For higher dimension covariance matrices it is suggested you use the inverse wishart distribution (transformed to a correlation matrix) for the simulations. The covariance/variance prior is simulated from RxODEs cvPost() function. 11.3.1 Simulation from inverse Wishart correlations An example of this simulation is below: ### Creating covariance matrix tmp &lt;- matrix(rnorm(8^2), 8, 8) tMat &lt;- tcrossprod(tmp, tmp) / (8 ^ 2) dimnames(tMat) &lt;- list(NULL, names(theta)) sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma, thetaMat=tMat, nStud=10, dfSub=10, dfObs=100) s &lt;-sim %&gt;% confint(c(&quot;centr&quot;, &quot;eff&quot;)) #&gt; summarizing data...done plot(s) If you wish you can see what omega and sigma was used for each virtual study by accessing them in the solved data object with $omega.list and $sigma.list: head(sim$omega.list) #&gt; [[1]] #&gt; [,1] #&gt; [1,] 0.5728809 #&gt; #&gt; [[2]] #&gt; [,1] #&gt; [1,] 0.3465021 #&gt; #&gt; [[3]] #&gt; [,1] #&gt; [1,] 0.1386869 #&gt; #&gt; [[4]] #&gt; [,1] #&gt; [1,] 0.1570577 #&gt; #&gt; [[5]] #&gt; [,1] #&gt; [1,] 0.1677731 #&gt; #&gt; [[6]] #&gt; [,1] #&gt; [1,] 0.3184372 head(sim$sigma.list) #&gt; [[1]] #&gt; [,1] [,2] #&gt; [1,] 0.093539238 0.007270049 #&gt; [2,] 0.007270049 0.098648424 #&gt; #&gt; [[2]] #&gt; [,1] [,2] #&gt; [1,] 0.109020277 -0.004127612 #&gt; [2,] -0.004127612 0.087054268 #&gt; #&gt; [[3]] #&gt; [,1] [,2] #&gt; [1,] 0.10606530 0.01457913 #&gt; [2,] 0.01457913 0.10189653 #&gt; #&gt; [[4]] #&gt; [,1] [,2] #&gt; [1,] 0.1025867133 -0.0007429996 #&gt; [2,] -0.0007429996 0.0962922149 #&gt; #&gt; [[5]] #&gt; [,1] [,2] #&gt; [1,] 0.098080929 -0.006730568 #&gt; [2,] -0.006730568 0.112366768 #&gt; #&gt; [[6]] #&gt; [,1] [,2] #&gt; [1,] 0.1123437 0.0188019 #&gt; [2,] 0.0188019 0.1021367 You can also see the parameter realizations from the $params data frame. 11.3.2 Simulate using variance/standard deviation standard errors Lets assume we wish to simulate from the nonmem run included in xpose First we setup the model: rx1 &lt;- RxODE({ cl &lt;- tcl*(1+crcl.cl*(CLCR-65)) * exp(eta.v) v &lt;- tv * WT * exp(eta.v) ka &lt;- tka * exp(eta.ka) ipred &lt;- linCmt() obs &lt;- ipred * (1 + prop.sd) + add.sd }) Next we input the estimated parameters: theta &lt;- c(tcl=2.63E+01, tv=1.35E+00, tka=4.20E+00, tlag=2.08E-01, prop.sd=2.05E-01, add.sd=1.06E-02, crcl.cl=7.17E-03, ## Note that since we are using the separation strategy the ETA variances are here too eta.cl=7.30E-02, eta.v=3.80E-02, eta.ka=1.91E+00) And also their covariances; To me, the easiest way to create a named covariance matrix is to use lotri(): thetaMat &lt;- lotri( tcl + tv + tka + tlag + prop.sd + add.sd + crcl.cl + eta.cl + eta.v + eta.ka ~ c(7.95E-01, 2.05E-02, 1.92E-03, 7.22E-02, -8.30E-03, 6.55E-01, -3.45E-03, -6.42E-05, 3.22E-03, 2.47E-04, 8.71E-04, 2.53E-04, -4.71E-03, -5.79E-05, 5.04E-04, 6.30E-04, -3.17E-06, -6.52E-04, -1.53E-05, -3.14E-05, 1.34E-05, -3.30E-04, 5.46E-06, -3.15E-04, 2.46E-06, 3.15E-06, -1.58E-06, 2.88E-06, -1.29E-03, -7.97E-05, 1.68E-03, -2.75E-05, -8.26E-05, 1.13E-05, -1.66E-06, 1.58E-04, -1.23E-03, -1.27E-05, -1.33E-03, -1.47E-05, -1.03E-04, 1.02E-05, 1.67E-06, 6.68E-05, 1.56E-04, 7.69E-02, -7.23E-03, 3.74E-01, 1.79E-03, -2.85E-03, 1.18E-05, -2.54E-04, 1.61E-03, -9.03E-04, 3.12E-01)) evw &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=100) %&gt;% ## For this problem we will simulate with sampling windows et(list(c(0, 0.5), c(0.5, 1), c(1, 3), c(3, 6), c(6, 12))) %&gt;% et(id=1:1000) ### From the run we know that: ### total number of observations is: 476 ### Total number of individuals: 74 sim &lt;- rxSolve(rx1, theta, evw, nSub=100, nStud=10, thetaMat=thetaMat, ## Match boundaries of problem thetaLower=0, sigma=c(&quot;prop.sd&quot;, &quot;add.sd&quot;), ## Sigmas are standard deviations sigmaXform=&quot;identity&quot;, # default sigma xform=&quot;identity&quot; omega=c(&quot;eta.cl&quot;, &quot;eta.v&quot;, &quot;eta.ka&quot;), ## etas are variances omegaXform=&quot;variance&quot;, # default omega xform=&quot;variance&quot; iCov=data.frame(WT=rnorm(1000, 70, 15), CLCR=rnorm(1000, 65, 25)), dfSub=74, dfObs=476); print(sim) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; # A tibble: 10,000 x 10 #&gt; sim.id id tcl crcl.cl CLCR eta.v tv WT tka eta.ka #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 27.0 1.04 54.0 0.907 2.00 71.8 5.69 -0.153 #&gt; 2 1 2 27.0 1.04 19.7 -0.225 2.00 80.2 5.69 0.249 #&gt; 3 1 3 27.0 1.04 45.7 1.66 2.00 66.3 5.69 0.236 #&gt; 4 1 4 27.0 1.04 73.9 0.556 2.00 69.4 5.69 -0.156 #&gt; 5 1 5 27.0 1.04 91.4 0.296 2.00 45.5 5.69 -0.331 #&gt; 6 1 6 27.0 1.04 94.9 -0.680 2.00 35.8 5.69 0.372 #&gt; 7 1 7 27.0 1.04 13.6 -0.327 2.00 95.9 5.69 -0.0760 #&gt; 8 1 8 27.0 1.04 66.2 0.589 2.00 57.3 5.69 0.688 #&gt; 9 1 9 27.0 1.04 71.7 -0.611 2.00 41.0 5.69 0.212 #&gt; 10 1 10 27.0 1.04 76.6 0.00250 2.00 66.5 5.69 0.243 #&gt; # … with 9,990 more rows #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; named numeric(0) #&gt; #&gt; Simulation with uncertainty in: #&gt; ● parameters (sim$thetaMat for changes) #&gt; ● omega matrix (sim$omegaList) #&gt; ● sigma matrix (sim$sigmaList) #&gt; #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 50,000 x 8 #&gt; sim.id id time cl v ka ipred obs #&gt; &lt;int&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0.20072222 -696. 356. 4.88 NA NA #&gt; 2 1 1 0.79938985 -696. 356. 4.88 NA NA #&gt; 3 1 1 2.50526151 -696. 356. 4.88 NA NA #&gt; 4 1 1 3.38595486 -696. 356. 4.88 NA NA #&gt; 5 1 1 9.28579107 -696. 356. 4.88 NA NA #&gt; 6 1 2 0.04197341 -992. 128. 7.30 NA NA #&gt; # … with 49,994 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ### Notice that the simulation time-points change for the individual ### If you want the same sampling time-points you can do that as well: evw &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=100) %&gt;% et(0, 24, length.out=50) %&gt;% et(id=1:100) sim &lt;- rxSolve(rx1, theta, evw, nSub=100, nStud=10, thetaMat=thetaMat, ## Match boundaries of problem thetaLower=0, sigma=c(&quot;prop.sd&quot;, &quot;add.sd&quot;), ## Sigmas are standard deviations sigmaXform=&quot;identity&quot;, # default sigma xform=&quot;identity&quot; omega=c(&quot;eta.cl&quot;, &quot;eta.v&quot;, &quot;eta.ka&quot;), ## etas are variances omegaXform=&quot;variance&quot;, # default omega xform=&quot;variance&quot; iCov=data.frame(WT=rnorm(1000, 70, 15), CLCR=rnorm(1000, 65, 25)), dfSub=74, dfObs=476) s &lt;-sim %&gt;% confint(c(&quot;ipred&quot;)) #&gt; summarizing data...done plot(s) 11.3.3 Simulate without uncertainty in omega or sigma parameters If you do not wish to sample from the prior distributions of either the omega or sigma matrices, you can turn off this feature by specifying the simVariability = FALSE option when solving: mod &lt;- RxODE({ eff(0) = 1 C2 = centr/V2; C3 = peri/V3; CL = TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; e = eff+eff.err cp = centr*(1+cp.err) }) theta &lt;- c(KA=2.94E-01, TCl=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects sigma &lt;- lotri(eff.err ~ 0.1, cp.err ~ 0.1) sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma, thetaMat=tMat, nStud=10, simVariability=FALSE) s &lt;-sim %&gt;% confint(c(&quot;centr&quot;, &quot;eff&quot;)) #&gt; summarizing data...done plot(s) Note since realizations of omega and sigma were not simulated, $omega.list and $sigma.list both return NULL. 11.3.3.0.1 RxODE multi-threaded solving and simulation RxODE now supports multi-threaded solving on OpenMP supported compilers, including linux and windows. Mac OSX can also be supported By default it uses all your available cores for solving as determined by rxCores(). This may be overkill depending on your system, at a certain point the speed of solving is limited by things other than computing power. You can also speed up simulation by using the multi-cores to generate random deviates with mvnfast (either mvnfast::rmvn() or mvnfast::rmvt()). This is controlled by the nCoresRV parameter. For example: sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma, thetaMat=tMat, nStud=10, nCoresRV=2); s &lt;-sim %&gt;% confint(c(&quot;eff&quot;, &quot;centr&quot;)) #&gt; summarizing data...done The default for this is 1 core since the result depends on the number of cores and the random seed you use in your simulation as well as the work-load each thread is sharing/architecture. However, you can always speed up this process with more cores if you are sure your collaborators have the same number of cores available to them and have OpenMP thread-capable compile. 11.4 Using prior data for solving RxODE can use a single subject or multiple subjects with a single event table to solve ODEs. Additionally, RxODE can use an arbitrary data frame with individualized events. For example when using nlmixr, you could use the RxODE/vignettes/theo_sd data frame library(RxODE) ### Load data from nlmixr d &lt;- qs::qread(&quot;RxODE/vignettes/theo_sd.qs&quot;) ### Create RxODE model theo &lt;- RxODE({ tka ~ 0.45 # Log Ka tcl ~ 1 # Log Cl tv ~ 3.45 # Log V eta.ka ~ 0.6 eta.cl ~ 0.3 eta.v ~ 0.1 ka &lt;- exp(tka + eta.ka) cl &lt;- exp(tcl + eta.cl) v &lt;- exp(tv + eta.v) d/dt(depot) = -ka * depot d/dt(center) = ka * depot - cl / v * center cp = center / v }) ### Create parameter dataset library(dplyr) parsDf &lt;- tribble( ~ eta.ka, ~ eta.cl, ~ eta.v, 0.105, -0.487, -0.080, 0.221, 0.144, 0.021, 0.368, 0.031, 0.058, -0.277, -0.015, -0.007, -0.046, -0.155, -0.142, -0.382, 0.367, 0.203, -0.791, 0.160, 0.047, -0.181, 0.168, 0.096, 1.420, 0.042, 0.012, -0.738, -0.391, -0.170, 0.790, 0.281, 0.146, -0.527, -0.126, -0.198) %&gt;% mutate(tka = 0.451, tcl = 1.017, tv = 3.449) ### Now solve the dataset solveData &lt;- rxSolve(theo, parsDf, d) plot(solveData, cp) print(solveData) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; # A tibble: 12 x 1 #&gt; id #&gt; &lt;fct&gt; #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 #&gt; 7 7 #&gt; 8 8 #&gt; 9 9 #&gt; 10 10 #&gt; 11 11 #&gt; 12 12 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; depot center #&gt; 0 0 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 132 x 8 #&gt; id time ka cl v cp depot center #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 2.86 3.67 34.8 0 320. 0 #&gt; 2 1 0.25 2.86 3.67 34.8 4.62 157. 161. #&gt; 3 1 0.570 2.86 3.67 34.8 7.12 62.8 248. #&gt; 4 1 1.12 2.86 3.67 34.8 8.09 13.0 282. #&gt; 5 1 2.02 2.86 3.67 34.8 7.68 0.996 267. #&gt; 6 1 3.82 2.86 3.67 34.8 6.38 0.00581 222. #&gt; # … with 126 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ### Of course the fasest way to solve if you don&#39;t care about the RxODE extra parameters is solveData &lt;- rxSolve(theo, parsDf, d, returnType=&quot;data.frame&quot;) ### solved data dplyr::as.tbl(solveData) #&gt; # A tibble: 132 x 8 #&gt; id time ka cl v cp depot center #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 2.86 3.67 34.8 0 3.20e+2 0 #&gt; 2 1 0.25 2.86 3.67 34.8 4.62 1.57e+2 161. #&gt; 3 1 0.570 2.86 3.67 34.8 7.12 6.28e+1 248. #&gt; 4 1 1.12 2.86 3.67 34.8 8.09 1.30e+1 282. #&gt; 5 1 2.02 2.86 3.67 34.8 7.68 9.96e-1 267. #&gt; 6 1 3.82 2.86 3.67 34.8 6.38 5.81e-3 222. #&gt; 7 1 5.1 2.86 3.67 34.8 5.58 1.50e-4 194. #&gt; 8 1 7.03 2.86 3.67 34.8 4.55 6.02e-7 158. #&gt; 9 1 9.05 2.86 3.67 34.8 3.68 1.77e-9 128. #&gt; 10 1 12.1 2.86 3.67 34.8 2.66 9.43e-9 92.6 #&gt; # … with 122 more rows data.table::data.table(solveData) #&gt; id time ka cl v cp depot center #&gt; 1: 1 0.00 2.857651 3.669297 34.81332 0.0000000 3.199920e+02 0.00000 #&gt; 2: 1 0.25 2.857651 3.669297 34.81332 4.6240421 1.566295e+02 160.97825 #&gt; 3: 1 0.57 2.857651 3.669297 34.81332 7.1151647 6.276731e+01 247.70249 #&gt; 4: 1 1.12 2.857651 3.669297 34.81332 8.0922106 1.303613e+01 281.71670 #&gt; 5: 1 2.02 2.857651 3.669297 34.81332 7.6837844 9.958446e-01 267.49803 #&gt; --- #&gt; 128: 12 5.07 2.857651 3.669297 34.81332 5.6044213 1.636210e-04 195.10850 #&gt; 129: 12 7.07 2.857651 3.669297 34.81332 4.5392337 5.385697e-07 158.02579 #&gt; 130: 12 9.03 2.857651 3.669297 34.81332 3.6920276 1.882087e-09 128.53173 #&gt; 131: 12 12.05 2.857651 3.669297 34.81332 2.6855080 8.461424e-09 93.49144 #&gt; 132: 12 24.15 2.857651 3.669297 34.81332 0.7501667 -4.775222e-10 26.11579 "],["examples.html", "Chapter 12 Examples 12.1 Prediction only models 12.2 Solved compartment models 12.3 Mixing Solved Systems and ODEs 12.4 Weight based dosing 12.5 Inter-occasion and other nesting examples 12.6 Transit compartment models", " Chapter 12 Examples This section is for example models to get you started in common simulation scenarios. 12.1 Prediction only models Prediction only models are simple to create. You use the RxODE syntax without any ODE systems in them. A very simple example is a one-compartment model. library(RxODE) mod &lt;- RxODE({ ipre &lt;- 10 * exp(-ke * t); }) mod #&gt; RxODE 1.0.5 model named rx_7e31c1ae655db7c06244b075015b3e86 model (✔ ready). #&gt; x$params: ke #&gt; x$lhs: ipre Solving the RxODE models are the same as saving the simple ODE system, but faster of course. et &lt;- et(seq(0,24,length.out=50)) cmt1 &lt;- rxSolve(mod,et,params=c(ke=0.5)) cmt1 #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters (x$params): ────────────────────────────────── #&gt; ke #&gt; 0.5 #&gt; ── Initial Conditions (x$inits): ─────────────────────────── #&gt; named numeric(0) #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 50 x 2 #&gt; time ipre #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 10 #&gt; 2 0.490 7.83 #&gt; 3 0.980 6.13 #&gt; 4 1.47 4.80 #&gt; 5 1.96 3.75 #&gt; 6 2.45 2.94 #&gt; # … with 44 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ 12.2 Solved compartment models Solved models are also simple to create. You simply place the linCmt() psuedo-function into your code. The linCmt() function figures out the type of model to use based on the parameter names specified. Most often, pharmacometric models are parameterized in terms of volume and clearances. Clearances are specified by NONMEM-style names of CL, Q, Q1, Q2, etc. or distributional clearances CLD, CLD2. Volumes are specified by Central (VC or V), Peripheral/Tissue (VP, VT). While more translations are available, some example translations are below: Another popular parameterization is in terms of micro-constants. RxODE assumes compartment 1 is the central compartment. The elimination constant would be specified by K, Ke or Kel. Some example translations are below: The last parameterization possible is using alpha and V and/or A/B/C. Some example translations are below: Once the linCmt() sleuthing is complete, the 1, 2 or 3 compartment model solution is used as the value of linCmt(). The compartments where you can dose in a linear solved system are depot and central when there is an linear absorption constant in the model ka. Without any additional ODEs, these compartments are numbered depot=1 and central=2. When the absorption constant ka is missing, you may only dose to the central compartment. Without any additional ODEs the compartment number is central=1. These compartments take the same sort of events that a ODE model can take, and are discussed in the RxODE events vignette. mod &lt;- RxODE({ ke &lt;- 0.5 V &lt;- 1 ipre &lt;- linCmt(); }) mod #&gt; RxODE 1.0.5 model named rx_d41c572184c0c5d136339f94b81154e8 model (✔ ready). #&gt; x$stateExtra: central #&gt; x$params: ke, V #&gt; x$lhs: ipre This then acts as an ODE model; You specify a dose to the depot compartment and then solve the system: et &lt;- et(amt=10,time=0,cmt=depot) %&gt;% et(seq(0,24,length.out=50)) cmt1 &lt;- rxSolve(mod,et,params=c(ke=0.5)) cmt1 #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters (x$params): ────────────────────────────────── #&gt; ke V #&gt; 0.5 1.0 #&gt; ── Initial Conditions (x$inits): ─────────────────────────── #&gt; named numeric(0) #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 50 x 2 #&gt; time ipre #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 10 #&gt; 2 0.490 7.83 #&gt; 3 0.980 6.13 #&gt; 4 1.47 4.80 #&gt; 5 1.96 3.75 #&gt; 6 2.45 2.94 #&gt; # … with 44 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ 12.3 Mixing Solved Systems and ODEs In addition to pure ODEs, you may mix solved systems and ODEs. The prior 2-compartment indirect response model can be simplified with a linCmt() function: library(RxODE) ## Setup example model mod1 &lt;-RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }); ## Seup parameters and initial conditions theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects inits &lt;- c(eff=1); ## Setup dosing event information ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120,dosing.interval=24) %&gt;% add.sampling(0:240); ## Setup a mixed solved/ode system: mod2 &lt;- RxODE({ ## the order of variables do not matter, the type of compartmental ## model is determined by the parameters specified. C2 = linCmt(KA, CL, V2, Q, V3); eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) This allows the indirect response model above to assign the 2-compartment model to the C2 variable and the used in the indirect response model. When mixing the solved systems and the ODEs, the solved system’s compartment is always the last compartment. This is because the solved system technically isn’t a compartment to be solved. Adding the dosing compartment to the end will not interfere with the actual ODE to be solved. Therefore,in the two-compartment indirect response model, the effect compartment is compartment #1 while the PK dosing compartment for the depot is compartment #2. This compartment model requires a new event table since the compartment number changed: ev &lt;- eventTable(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12,dosing.to=2) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120,dosing.interval=24,dosing.to=2) %&gt;% add.sampling(0:240); This can be solved with the following command: x &lt;- mod2 %&gt;% solve(theta, ev) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; CL V2 Q V3 KA Kin Kout EC50 #&gt; 18.600 40.200 10.500 297.000 0.294 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Note this solving did not require specifying the effect compartment initial condition to be 1. Rather, this is already pre-specified by eff(0)=1. This can be solved for different initial conditions easily: x &lt;- mod2 %&gt;% solve(theta, ev,c(eff=2)) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; CL V2 Q V3 KA Kin Kout EC50 #&gt; 18.600 40.200 10.500 297.000 0.294 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; eff #&gt; 2 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 2 #&gt; 2 1 121. 1.93 #&gt; 3 2 60.3 1.67 #&gt; 4 3 31.0 1.41 #&gt; 5 4 17.0 1.23 #&gt; 6 5 10.2 1.13 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ The RxODE detective also does not require you to specify the variables in the linCmt() function if they are already defined in the block. Therefore, the following function will also work to solve the same system. mod3 &lt;- RxODE({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; ## The linCmt() picks up the variables from above C2 = linCmt(); eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) x &lt;- mod3 %&gt;% solve(ev) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Note that you do not specify the parameters when solving the system since they are built into the model, but you can override the parameters: x &lt;- mod3 %&gt;% solve(c(KA=10),ev) print(x) #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ Solved RxODE object ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ #&gt; ── Parameters ($params): ─────────────────────────────────── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 10.0 18.6 40.2 10.5 297.0 1.0 1.0 200.0 #&gt; ── Initial Conditions ($inits): ──────────────────────────── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ──────────────────────────── #&gt; # A tibble: 241 x 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # … with 235 more rows #&gt; ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ 12.4 Weight based dosing This is an example model for weight based dosing of daptomycin. Daptomycin is a cyclic lipopeptide antibiotic from fermented Streptomyces roseosporus. There are 3 stages for weight-based dosing simulations: - Create RxODE model - Simulate Covariates - Create event table with weight-based dosing (merged back to covariates) 12.4.1 Creating a 2-compartment model in RxODE library(RxODE) ## Note the time covariate is not included in the simulation m1 &lt;- RxODE({ CL ~ (1-0.2*SEX)*(0.807+0.00514*(CRCL-91.2))*exp(eta.cl) V1 ~ 4.8*exp(eta.v1) Q ~ (3.46+0.0593*(WT-75.1))*exp(eta.q); V2 ~ 1.93*(3.13+0.0458*(WT-75.1))*exp(eta.v2) A1 ~ centr; A2 ~ peri; d/dt(centr) ~ - A1*(CL/V1 + Q/V1) + A2*Q/V2; d/dt(peri) ~ A1*Q/V1 - A2*Q/V2; DV = centr / V1 * (1 + prop.err) }) 12.4.2 Simulating Covariates This simulation correlates age, sex, and weight. Since we will be using weight based dosing, this needs to be simulated first set.seed(42) library(dplyr) nsub=30 ### Simulate Weight based on age and gender AGE&lt;-round(runif(nsub,min=18,max=70)) SEX&lt;-round(runif(nsub,min=0,max=1)) HTm&lt;-round(rnorm(nsub,176.3,0.17*sqrt(4482)),digits=1) HTf&lt;-round(rnorm(nsub,162.2,0.16*sqrt(4857)),digits=1) WTm&lt;-round(exp(3.28+1.92*log(HTm/100))*exp(rnorm(nsub,0,0.14)),digits=1) WTf&lt;-round(exp(3.49+1.45*log(HTf/100))*exp(rnorm(nsub,0,0.17)),digits=1) WT&lt;-ifelse(SEX==1,WTf,WTm) CRCL&lt;-round(runif(nsub,30,140)) ## id is in lower case to match the event table cov.df &lt;- tibble(id=seq_along(AGE), AGE=AGE, SEX=SEX, WT=WT, CRCL=CRCL) print(cov.df) #&gt; # A tibble: 30 x 5 #&gt; id AGE SEX WT CRCL #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 66 1 49.4 83 #&gt; 2 2 67 1 52.5 79 #&gt; 3 3 33 0 97.9 37 #&gt; 4 4 61 1 63.8 66 #&gt; 5 5 51 0 71.8 127 #&gt; 6 6 45 1 69.6 132 #&gt; 7 7 56 0 61 73 #&gt; 8 8 25 0 57.7 47 #&gt; 9 9 52 1 58.7 65 #&gt; 10 10 55 1 73.1 64 #&gt; # ... with 20 more rows 12.4.3 Creating weight based event table s&lt;-c(0,0.25,0.5,0.75,1,1.5,seq(2,24,by=1)) s &lt;- lapply(s, function(x){.x &lt;- 0.1 * x; c(x - .x, x + .x)}) e &lt;- et() %&gt;% ## Specify the id and weight based dosing from covariate data.frame ## This requires RxODE XXX et(id=cov.df$id, amt=6*cov.df$WT, rate=6 * cov.df$WT) %&gt;% ## Sampling is added for each ID et(s) %&gt;% as.data.frame %&gt;% ## Merge the event table with the covarite information merge(cov.df, by=&quot;id&quot;) %&gt;% as_tibble e #&gt; # A tibble: 900 x 12 #&gt; id low time high cmt amt rate evid AGE SEX WT CRCL #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0 0 (obs) NA NA 0 66 1 49.4 83 #&gt; 2 1 NA 0 NA (default) 296. 296. 1 66 1 49.4 83 #&gt; 3 1 0.225 0.246 0.275 (obs) NA NA 0 66 1 49.4 83 #&gt; 4 1 0.45 0.516 0.55 (obs) NA NA 0 66 1 49.4 83 #&gt; 5 1 0.675 0.729 0.825 (obs) NA NA 0 66 1 49.4 83 #&gt; 6 1 0.9 0.921 1.1 (obs) NA NA 0 66 1 49.4 83 #&gt; 7 1 1.35 1.42 1.65 (obs) NA NA 0 66 1 49.4 83 #&gt; 8 1 1.8 1.82 2.2 (obs) NA NA 0 66 1 49.4 83 #&gt; 9 1 2.7 2.97 3.3 (obs) NA NA 0 66 1 49.4 83 #&gt; 10 1 3.6 3.87 4.4 (obs) NA NA 0 66 1 49.4 83 #&gt; # ... with 890 more rows 12.4.4 Solving Daptomycin simulation data &lt;- rxSolve(m1, e, ## Lotri uses lower-triangular matrix rep. for named matrix omega=lotri(eta.cl ~ .306, eta.q ~0.0652, eta.v1 ~.567, eta.v2 ~ .191), sigma=lotri(prop.err ~ 0.15), addDosing = TRUE, addCov = TRUE) print(data) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; # A tibble: 30 x 5 #&gt; id eta.cl eta.v1 eta.q eta.v2 #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.563 0.580 0.0360 -0.246 #&gt; 2 2 0.0341 0.406 -0.139 -0.481 #&gt; 3 3 -0.447 0.0952 -0.185 -0.249 #&gt; 4 4 -0.988 0.248 -0.131 -0.449 #&gt; 5 5 0.144 -1.14 0.106 0.360 #&gt; 6 6 -0.689 0.407 -0.193 -0.200 #&gt; 7 7 -0.426 -0.706 -0.190 -0.234 #&gt; 8 8 -0.212 0.728 0.335 0.0665 #&gt; 9 9 0.0884 -0.934 0.337 0.154 #&gt; 10 10 -0.557 1.29 0.0163 -0.140 #&gt; # ... with 20 more rows #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; centr peri #&gt; 0 0 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 900 x 9 #&gt; id evid cmt amt time DV SEX WT CRCL #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 1 296. 0 0 1 49.4 83 #&gt; 2 1 0 NA NA 0 0 1 49.4 83 #&gt; 3 1 0 NA NA 0.246 2.32 1 49.4 83 #&gt; 4 1 0 NA NA 0.516 19.6 1 49.4 83 #&gt; 5 1 0 NA NA 0.729 23.2 1 49.4 83 #&gt; 6 1 0 NA NA 0.921 21.1 1 49.4 83 #&gt; # ... with 894 more rows #&gt; ________________________________________________________________________________ plot(data, log=&quot;y&quot;) #&gt; Warning in self$trans$transform(x): NaNs produced #&gt; Warning: Transformation introduced infinite values in continuous y-axis 12.4.5 Daptomycin Reference This weight-based simulation is adapted from the Daptomycin article below: Dvorchik B, Arbeit RD, Chung J, Liu S, Knebel W, Kastrissios H. Population pharmacokinetics of daptomycin. Antimicrob Agents Che mother 2004; 48: 2799-2807. doi:(10.1128/AAC.48.8.2799-2807.2004)[https://dx.doi.org/10.1128%2FAAC.48.8.2799-2807.2004] This simulation example was made available from the work of Sherwin Sy with modifications by Matthew Fidler 12.5 Inter-occasion and other nesting examples More than one level of nesting is possible in RxODE; In this example we will be using the following uncertainties and sources of variability: Level Variable Matrix specified Integrated Matrix Model uncertainty NA thetaMat thetaMat Investigator inv.Cl, inv.Ka omega theta Subject eta.Cl, eta.Ka omega omega Eye eye.Cl, eye.Ka omega omega Occasion iov.Cl, occ.Ka omega omega Unexplained Concentration prop.sd sigma sigma Unexplained Effect add.sd sigma sigma 12.5.1 Event table This event table contains nesting variables: inv: investigator id id: subject id eye: eye id (left or right) occ: occasion library(RxODE) library(dplyr) et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(seq(0, 240, by=4)) %&gt;% # Assumes sampling when there is no dosing information et(seq(0, 240, by=4) + 0.1) %&gt;% ## adds 0.1 for separate eye et(id=1:20) %&gt;% ## Add an occasion per dose mutate(occ=cumsum(!is.na(amt))) %&gt;% mutate(occ=ifelse(occ == 0, 1, occ)) %&gt;% mutate(occ=2- occ %% 2) %&gt;% mutate(eye=ifelse(round(time) == time, 1, 2)) %&gt;% mutate(inv=ifelse(id &lt; 10, 1, 2)) %&gt;% as_tibble -&gt; ev 12.5.2 RxODE model This creates the RxODE model with multi-level nesting. Note the variables inv.Cl, inv.Ka, eta.Cl etc; You only need one variable for each level of nesting. mod &lt;- RxODE({ ## Clearance with individuals eff(0) = 1 C2 = centr/V2*(1+prop.sd); C3 = peri/V3; CL = TCl*exp(eta.Cl + eye.Cl + iov.Cl + inv.Cl) KA = TKA * exp(eta.Ka + eye.Ka + iov.Cl + inv.Ka) d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; ef0 = eff + add.sd }) 12.5.3 Uncertainty in Model parameters theta &lt;- c(&quot;TKA&quot;=0.294, &quot;TCl&quot;=18.6, &quot;V2&quot;=40.2, &quot;Q&quot;=10.5, &quot;V3&quot;=297, &quot;Kin&quot;=1, &quot;Kout&quot;=1, &quot;EC50&quot;=200) ## Creating covariance matrix tmp &lt;- matrix(rnorm(8^2), 8, 8) tMat &lt;- tcrossprod(tmp, tmp) / (8 ^ 2) dimnames(tMat) &lt;- list(names(theta), names(theta)) tMat #&gt; TKA TCl V2 Q V3 #&gt; TKA 0.084901793 0.008491535 -0.028211905 -0.083460075 0.058187918 #&gt; TCl 0.008491535 0.074011602 -0.047388281 -0.049711532 0.009450000 #&gt; V2 -0.028211905 -0.047388281 0.094485793 -0.001142105 -0.031424916 #&gt; Q -0.083460075 -0.049711532 -0.001142105 0.271685090 -0.042012559 #&gt; V3 0.058187918 0.009450000 -0.031424916 -0.042012559 0.089992792 #&gt; Kin -0.046169545 -0.016205743 -0.014705754 0.094478654 0.001534101 #&gt; Kout -0.023946567 -0.040201822 0.008377087 0.062087105 -0.053276590 #&gt; EC50 -0.017733886 -0.011145761 -0.004038295 0.025496213 0.006360558 #&gt; Kin Kout EC50 #&gt; TKA -0.046169545 -0.023946567 -0.017733886 #&gt; TCl -0.016205743 -0.040201822 -0.011145761 #&gt; V2 -0.014705754 0.008377087 -0.004038295 #&gt; Q 0.094478654 0.062087105 0.025496213 #&gt; V3 0.001534101 -0.053276590 0.006360558 #&gt; Kin 0.102223150 0.035112776 0.030704006 #&gt; Kout 0.035112776 0.109746574 0.019060142 #&gt; EC50 0.030704006 0.019060142 0.030188688 12.5.4 Nesting Variability To specify multiple levels of nesting, you can specify it as a nested lotri matrix; When using this approach you use the condition operator | to specify what variable nesting occurs on; For the Bayesian simulation we need to specify how much information we have for each parameter; For RxODE this is the nu parameter. In this case: - id, nu=100 or the model came from 100 subjects - eye, nu=200 or the model came from 200 eyes - occ, nu=200 or the model came from 200 occasions - inv, nu=10 or the model came from 10 investigators To specify this in lotri you can use | var(nu=X), or: omega &lt;- lotri(lotri(eta.Cl ~ 0.1, eta.Ka ~ 0.1) | id(nu=100), lotri(eye.Cl ~ 0.05, eye.Ka ~ 0.05) | eye(nu=200), lotri(iov.Cl ~ 0.01, iov.Ka ~ 0.01) | occ(nu=200), lotri(inv.Cl ~ 0.02, inv.Ka ~ 0.02) | inv(nu=10)) omega #&gt; $id #&gt; eta.Cl eta.Ka #&gt; eta.Cl 0.1 0.0 #&gt; eta.Ka 0.0 0.1 #&gt; #&gt; $eye #&gt; eye.Cl eye.Ka #&gt; eye.Cl 0.05 0.00 #&gt; eye.Ka 0.00 0.05 #&gt; #&gt; $occ #&gt; iov.Cl iov.Ka #&gt; iov.Cl 0.01 0.00 #&gt; iov.Ka 0.00 0.01 #&gt; #&gt; $inv #&gt; inv.Cl inv.Ka #&gt; inv.Cl 0.02 0.00 #&gt; inv.Ka 0.00 0.02 #&gt; #&gt; Properties: nu 12.5.5 Unexplained variability The last piece of variability to specify is the unexplained variability sigma &lt;- lotri(prop.sd ~ .25, add.sd~ 0.125) 12.5.6 Solving the problem s &lt;- rxSolve(mod, theta, ev, thetaMat=tMat, omega=omega, sigma=sigma, sigmaDf=400, nStud=400) #&gt; unhandled error message: EE:[lsoda] 70000 steps taken before reaching tout #&gt; @(lsoda.c:748 #&gt; Warning: some ID(s) could not solve the ODEs correctly; These values are #&gt; replaced with &#39;NA&#39; print(s) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; # A tibble: 8,000 x 24 #&gt; sim.id id `inv.Cl(inv==1)` `inv.Cl(inv==2)` `inv.Ka(inv==1)` #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0.0186 0.116 0.188 #&gt; 2 1 2 0.0186 0.116 0.188 #&gt; 3 1 3 0.0186 0.116 0.188 #&gt; 4 1 4 0.0186 0.116 0.188 #&gt; 5 1 5 0.0186 0.116 0.188 #&gt; 6 1 6 0.0186 0.116 0.188 #&gt; 7 1 7 0.0186 0.116 0.188 #&gt; 8 1 8 0.0186 0.116 0.188 #&gt; 9 1 9 0.0186 0.116 0.188 #&gt; 10 1 10 0.0186 0.116 0.188 #&gt; # ... with 7,990 more rows, and 19 more variables: inv.Ka(inv==2) &lt;dbl&gt;, #&gt; # eye.Cl(eye==1) &lt;dbl&gt;, eye.Cl(eye==2) &lt;dbl&gt;, eye.Ka(eye==1) &lt;dbl&gt;, #&gt; # eye.Ka(eye==2) &lt;dbl&gt;, iov.Cl(occ==1) &lt;dbl&gt;, iov.Cl(occ==2) &lt;dbl&gt;, #&gt; # iov.Ka(occ==1) &lt;dbl&gt;, iov.Ka(occ==2) &lt;dbl&gt;, V2 &lt;dbl&gt;, V3 &lt;dbl&gt;, TCl &lt;dbl&gt;, #&gt; # eta.Cl &lt;dbl&gt;, TKA &lt;dbl&gt;, eta.Ka &lt;dbl&gt;, Q &lt;dbl&gt;, Kin &lt;dbl&gt;, Kout &lt;dbl&gt;, #&gt; # EC50 &lt;dbl&gt; #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; #&gt; Simulation with uncertainty in: #&gt; * parameters (s$thetaMat for changes) #&gt; * omega matrix (s$omegaList) #&gt; #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 976,000 x 18 #&gt; sim.id id time inv.Cl inv.Ka eye.Cl eye.Ka iov.Cl iov.Ka C2 C3 #&gt; &lt;int&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0.0 0.0186 0.188 -0.104 0.0786 0.0247 -0.0530 0 0 #&gt; 2 1 1 0.1 0.0186 0.188 -0.296 0.0588 0.0247 -0.0530 3.00 0.0281 #&gt; 3 1 1 4.0 0.0186 0.188 -0.104 0.0786 0.0247 -0.0530 22.4 9.90 #&gt; 4 1 1 4.1 0.0186 0.188 -0.296 0.0588 0.0247 -0.0530 57.9 10.1 #&gt; 5 1 1 8.0 0.0186 0.188 -0.104 0.0786 0.0247 -0.0530 20.1 12.4 #&gt; 6 1 1 8.1 0.0186 0.188 -0.296 0.0588 0.0247 -0.0530 15.6 12.4 #&gt; # ... with 975,994 more rows, and 7 more variables: CL &lt;dbl&gt;, KA &lt;dbl&gt;, #&gt; # ef0 &lt;dbl&gt;, depot &lt;dbl&gt;, centr &lt;dbl&gt;, peri &lt;dbl&gt;, eff &lt;dbl&gt; #&gt; ________________________________________________________________________________ There are multiple investigators in a study; Each investigator has a number of individuals enrolled at their site. RxODE automatically determines the number of investigators and then will simulate an effect for each investigator. With the output, inv.Cl(inv==1) will be the inv.Cl for investigator 1, inv.Cl(inv==2) will be the inv.Cl for investigator 2, etc. inv.Cl(inv==1), inv.Cl(inv==2), etc will be simulated for each study and then combined to form the between investigator variability. In equation form these represent the following: inv.Cl = (inv == 1) * `inv.Cl(inv==1)` + (inv == 2) * `inv.Cl(inv==2)` If you look at the simulated parameters you can see inv.Cl(inv==1) and inv.Cl(inv==2) are in the s$params; They are the same for each study: print(head(s$params)) #&gt; sim.id id inv.Cl(inv==1) inv.Cl(inv==2) inv.Ka(inv==1) inv.Ka(inv==2) #&gt; 1 1 1 0.01864161 0.1159198 0.1878234 -0.292727 #&gt; 2 1 2 0.01864161 0.1159198 0.1878234 -0.292727 #&gt; 3 1 3 0.01864161 0.1159198 0.1878234 -0.292727 #&gt; 4 1 4 0.01864161 0.1159198 0.1878234 -0.292727 #&gt; 5 1 5 0.01864161 0.1159198 0.1878234 -0.292727 #&gt; 6 1 6 0.01864161 0.1159198 0.1878234 -0.292727 #&gt; eye.Cl(eye==1) eye.Cl(eye==2) eye.Ka(eye==1) eye.Ka(eye==2) iov.Cl(occ==1) #&gt; 1 -0.10410790 -0.29632211 0.07855205 0.05884539 0.02466606 #&gt; 2 -0.06820792 0.06585538 0.34603340 0.20141355 -0.06976537 #&gt; 3 -0.04885836 0.13135196 -0.13256387 0.21645151 -0.03121109 #&gt; 4 0.20667975 -0.08775327 -0.01404241 -0.04239568 -0.08207797 #&gt; 5 0.04877033 -0.22890756 -0.21685969 0.04846680 -0.01393029 #&gt; 6 0.19830134 -0.33204702 -0.16960164 0.06823678 -0.17462695 #&gt; iov.Cl(occ==2) iov.Ka(occ==1) iov.Ka(occ==2) V2 V3 TCl #&gt; 1 -0.11264526 -0.052971164 -0.106088075 39.57653 297.3736 18.81115 #&gt; 2 0.03970507 -0.073742566 0.090882718 39.57653 297.3736 18.81115 #&gt; 3 -0.23892944 -0.136470596 0.067412442 39.57653 297.3736 18.81115 #&gt; 4 -0.02134625 -0.061910605 -0.072601879 39.57653 297.3736 18.81115 #&gt; 5 0.05580236 0.099876044 -0.094708943 39.57653 297.3736 18.81115 #&gt; 6 -0.03152016 -0.002074008 -0.004758332 39.57653 297.3736 18.81115 #&gt; eta.Cl TKA eta.Ka Q Kin Kout EC50 #&gt; 1 -0.02740884 0.4375889 0.07529548 10.97588 1.179938 0.9161172 200.2625 #&gt; 2 -0.11896272 0.4375889 0.07490355 10.97588 1.179938 0.9161172 200.2625 #&gt; 3 -0.61026874 0.4375889 -0.15964154 10.97588 1.179938 0.9161172 200.2625 #&gt; 4 -0.17447915 0.4375889 -0.19377239 10.97588 1.179938 0.9161172 200.2625 #&gt; 5 0.26213020 0.4375889 -0.38954283 10.97588 1.179938 0.9161172 200.2625 #&gt; 6 -0.22932331 0.4375889 -0.49123723 10.97588 1.179938 0.9161172 200.2625 print(head(s$params %&gt;% filter(sim.id == 2))) #&gt; sim.id id inv.Cl(inv==1) inv.Cl(inv==2) inv.Ka(inv==1) inv.Ka(inv==2) #&gt; 1 2 1 -0.01105301 -0.1209402 0.3370577 0.0902204 #&gt; 2 2 2 -0.01105301 -0.1209402 0.3370577 0.0902204 #&gt; 3 2 3 -0.01105301 -0.1209402 0.3370577 0.0902204 #&gt; 4 2 4 -0.01105301 -0.1209402 0.3370577 0.0902204 #&gt; 5 2 5 -0.01105301 -0.1209402 0.3370577 0.0902204 #&gt; 6 2 6 -0.01105301 -0.1209402 0.3370577 0.0902204 #&gt; eye.Cl(eye==1) eye.Cl(eye==2) eye.Ka(eye==1) eye.Ka(eye==2) iov.Cl(occ==1) #&gt; 1 -0.01262553 -0.08161227 -0.238499594 0.17178813 0.08330981 #&gt; 2 -0.06778157 0.29410669 -0.003700213 -0.03805489 -0.12869095 #&gt; 3 0.06059738 -0.16831575 -0.085582067 0.22970053 0.05711749 #&gt; 4 -0.13086494 0.02748735 -0.056454551 -0.23331112 0.07216869 #&gt; 5 -0.23416424 -0.13568099 -0.436719663 -0.03106162 -0.13191139 #&gt; 6 0.24092815 0.66166495 -0.345840539 0.13552870 0.03987511 #&gt; iov.Cl(occ==2) iov.Ka(occ==1) iov.Ka(occ==2) V2 V3 TCl #&gt; 1 -0.148592318 0.10100830 0.050123275 40.32538 296.5826 18.65152 #&gt; 2 -0.002200205 -0.04045931 -0.077835601 40.32538 296.5826 18.65152 #&gt; 3 -0.185116411 0.02903611 0.076384740 40.32538 296.5826 18.65152 #&gt; 4 0.101902663 0.04680555 0.054662894 40.32538 296.5826 18.65152 #&gt; 5 0.103696663 0.02589958 0.100946619 40.32538 296.5826 18.65152 #&gt; 6 0.023244426 -0.03067335 -0.009347601 40.32538 296.5826 18.65152 #&gt; eta.Cl TKA eta.Ka Q Kin Kout EC50 #&gt; 1 -0.2518665 -0.2160777 0.33092617 11.02462 1.122102 1.022177 199.9981 #&gt; 2 0.3495104 -0.2160777 -0.35774607 11.02462 1.122102 1.022177 199.9981 #&gt; 3 -0.3101379 -0.2160777 -0.09014428 11.02462 1.122102 1.022177 199.9981 #&gt; 4 -0.1665144 -0.2160777 -0.11974060 11.02462 1.122102 1.022177 199.9981 #&gt; 5 0.3184297 -0.2160777 -0.06982612 11.02462 1.122102 1.022177 199.9981 #&gt; 6 -0.1216137 -0.2160777 0.30275205 11.02462 1.122102 1.022177 199.9981 For between eye variability and between occasion variability each individual simulates a number of variables that become the between eye and between occasion variability; In the case of the eye: eye.Cl = (eye == 1) * `eye.Cl(eye==1)` + (eye == 2) * `eye.Cl(eye==2)` So when you look the simulation each of these variables (ie eye.Cl(eye==1), eye.Cl(eye==2), etc) they change for each individual and when combined make the between eye variability or the between occasion variability that can be seen in some pharamcometric models. 12.6 Transit compartment models Savic 2008 first introduced the idea of transit compartments being a mechanistic explanation of a a lag-time type phenomena. RxODE has special handling of these models: You can specify this in a similar manner as the original paper: library(RxODE) mod &lt;- RxODE({ ## Table 3 from Savic 2007 cl = 17.2 # (L/hr) vc = 45.1 # L ka = 0.38 # 1/hr mtt = 0.37 # hr bio=1 n = 20.1 k = cl/vc ktr = (n+1)/mtt ## note that lgammafn is the same as lgamma in R. d/dt(depot) = exp(log(bio*podo)+log(ktr)+n*log(ktr*t)-ktr*t-lgammafn(n+1))-ka*depot d/dt(cen) = ka*depot-k*cen }) et &lt;- eventTable(); et$add.sampling(seq(0, 7, length.out=200)); et$add.dosing(20, start.time=0); transit &lt;- rxSolve(mod, et, transit_abs=TRUE) plot(transit, cen, ylab=&quot;Central Concentration&quot;) Another option is to specify the transit compartment function transit syntax. This specifies the parameters transit(number of transit compartments, mean transit time, bioavailability). The bioavailability term is optional. Using the transit code also automatically turns on the transit_abs option. Therefore, the same model can be specified by: mod &lt;- RxODE({ ## Table 3 from Savic 2007 cl = 17.2 # (L/hr) vc = 45.1 # L ka = 0.38 # 1/hr mtt = 0.37 # hr bio=1 n = 20.1 k = cl/vc ktr = (n+1)/mtt d/dt(depot) = transit(n,mtt,bio)-ka*depot d/dt(cen) = ka*depot-k*cen }) et &lt;- eventTable(); et$add.sampling(seq(0, 7, length.out=200)); et$add.dosing(20, start.time=0); transit &lt;- rxSolve(mod, et) #&gt; Warning: assumed transit compartment model since &#39;podo&#39; is in the model plot(transit, cen, ylab=&quot;Central Concentration&quot;) "],["advanced-miscellaneous-topics.html", "Chapter 13 Advanced &amp; Miscellaneous Topics 13.1 Covariates in RxODE 13.2 Shiny and RxODE 13.3 Using RxODE with a pipeline 13.4 Speeding up RxODE 13.5 Integrating RxODE models in your package 13.6 Stiff ODEs with Jacobian Specification", " Chapter 13 Advanced &amp; Miscellaneous Topics This covers advanced or miscellaneous topics in RxODE 13.1 Covariates in RxODE 13.1.1 Individual Covariates If there is an individual covariate you wish to solve for you may specify it by the iCov dataset: library(RxODE) library(units) library(xgxr) mod3 &lt;- RxODE({ KA=2.94E-01; #### Clearance with individuals CL=1.86E+01 * (WT / 70) ^ 0.75; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; #### The linCmt() picks up the variables from above C2 = linCmt(); Tz= 8 amp=0.1 eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) ev &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=1) %&gt;% et(0,48,length.out=100) %&gt;% et(id=1:4); set.seed(10) #### Now use iCov to simulate a 4-id sample r1 &lt;- solve(mod3, ev, ### Create individual covariate data-frame iCov=data.frame(id=1:4, WT=rnorm(4, 70, 10)), ### in this case it would be useful to keep the WT in the output dataset keep=&quot;WT&quot;) print(r1) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; # A tibble: 4 x 11 #&gt; id KA WT V2 Q V3 Kin Kout EC50 Tz amp #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.294 70.2 40.2 10.5 297 1 1 200 8 0.1 #&gt; 2 2 0.294 68.2 40.2 10.5 297 1 1 200 8 0.1 #&gt; 3 3 0.294 56.3 40.2 10.5 297 1 1 200 8 0.1 #&gt; 4 4 0.294 64.0 40.2 10.5 297 1 1 200 8 0.1 #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; eff #&gt; 1 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 400 x 6 #&gt; id time CL C2 eff WT #&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.0000000 18.6 0 1 70.2 #&gt; 2 1 0.4848485 18.6 27.8 1.03 70.2 #&gt; 3 1 0.9696970 18.6 43.7 1.08 70.2 #&gt; 4 1 1.4545455 18.6 51.7 1.13 70.2 #&gt; 5 1 1.9393939 18.6 54.7 1.18 70.2 #&gt; 6 1 2.4242424 18.6 54.5 1.21 70.2 #&gt; # ... with 394 more rows #&gt; ________________________________________________________________________________ plot(r1, C2, log=&quot;y&quot;) #&gt; Warning: Transformation introduced infinite values in continuous y-axis 13.1.2 Time Varying Covariates Covariates are easy to specify in RxODE, you can specify them as a variable. Time-varying covariates, like clock time in a circadian rhythm model, can also be used. Extending the indirect response model already discussed, we have: library(RxODE) library(units) mod3 &lt;- RxODE({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin0=1; Kout=1; EC50=200; #### The linCmt() picks up the variables from above C2 = linCmt(); Tz= 8 amp=0.1 eff(0) = 1 ## This specifies that the effect compartment starts at 1. #### Kin changes based on time of day (like cortosol) Kin = Kin0 +amp *cos(2*pi*(ctime-Tz)/24) d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=1, dosing.to=1) %&gt;% add.sampling(seq(0,48,length.out=100)); #### Create data frame of 8 am dosing for the first dose This is done #### with base R but it can be done with dplyr or data.table ev$ctime &lt;- (ev$time+set_units(8,hr)) %% 24 Now there is a covariate present in the event dataset, the system can be solved by combining the dataset and the model: r1 &lt;- solve(mod3, ev, covs_interpolation=&quot;linear&quot;) print(r1) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; KA CL V2 Q V3 Kin0 Kout #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 1.000000 #&gt; EC50 Tz amp pi #&gt; 200.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; eff #&gt; 1 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 100 x 4 #&gt; time C2 Kin eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0000000 0 1.1 1 #&gt; 2 0.4848485 27.8 1.10 1.07 #&gt; 3 0.9696970 43.7 1.10 1.15 #&gt; 4 1.4545455 51.8 1.09 1.22 #&gt; 5 1.9393939 54.8 1.09 1.27 #&gt; 6 2.4242424 54.6 1.08 1.30 #&gt; # ... with 94 more rows #&gt; ________________________________________________________________________________ When solving ODE equations, the solver may sample times outside of the data. When this happens, this ODE solver can use linear interpolation between the covariate values. It is equivalent to R’s approxfun with method=\"linear\". plot(r1,C2, ylab=&quot;Central Concentration&quot;) plot(r1,eff) + ylab(&quot;Effect&quot;) + xlab(&quot;Time&quot;); Note that the linear approximation in this case leads to some kinks in the solved system at 24-hours where the covariate has a linear interpolation between near 24 and near 0. While linear seems reasonable, cases like clock time make other interpolation methods more attractive. In RxODE the default covariate interpolation is be the last observation carried forward (locf), or constant approximation. This is equivalent to R’s approxfun with method=\"constant\". r1 &lt;- solve(mod3, ev,covs_interpolation=&quot;constant&quot;) print(r1) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; KA CL V2 Q V3 Kin0 Kout #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 1.000000 #&gt; EC50 Tz amp pi #&gt; 200.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; eff #&gt; 1 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 100 x 4 #&gt; time C2 Kin eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0000000 0 1.1 1 #&gt; 2 0.4848485 27.8 1.10 1.07 #&gt; 3 0.9696970 43.7 1.10 1.15 #&gt; 4 1.4545455 51.8 1.09 1.22 #&gt; 5 1.9393939 54.8 1.09 1.27 #&gt; 6 2.4242424 54.6 1.08 1.31 #&gt; # ... with 94 more rows #&gt; ________________________________________________________________________________ which gives the following plots: plot(r1,C2, ylab=&quot;Central Concentration&quot;, xlab=&quot;Time&quot;) plot(r1,eff, ylab=&quot;Effect&quot;, xlab=&quot;Time&quot;) In this case, the plots seem to be smoother. You can also use NONMEM’s preferred interpolation style of next observation carried backward (NOCB): r1 &lt;- solve(mod3, ev,covs_interpolation=&quot;nocb&quot;) print(r1) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; KA CL V2 Q V3 Kin0 Kout #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 1.000000 #&gt; EC50 Tz amp pi #&gt; 200.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; eff #&gt; 1 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 100 x 4 #&gt; time C2 Kin eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0000000 0 1.1 1 #&gt; 2 0.4848485 27.8 1.10 1.07 #&gt; 3 0.9696970 43.7 1.10 1.15 #&gt; 4 1.4545455 51.8 1.09 1.21 #&gt; 5 1.9393939 54.8 1.09 1.27 #&gt; 6 2.4242424 54.6 1.08 1.30 #&gt; # ... with 94 more rows #&gt; ________________________________________________________________________________ which gives the following plots: plot(r1,C2, ylab=&quot;Central Concentration&quot;, xlab=&quot;Time&quot;) plot(r1,eff, ylab=&quot;Effect&quot;, xlab=&quot;Time&quot;) 13.2 Shiny and RxODE 13.2.1 Facilities for generating R shiny applications An example of creating an R shiny application to interactively explore responses of various complex dosing regimens is available at http://qsp.engr.uga.edu:3838/RxODE/RegimenSimulator. Shiny applications like this one may be programmatically created with the experimental function genShinyApp.template(). The above application includes widgets for varying the dose, dosing regimen, dose cycle, and number of cycles. genShinyApp.template(appDir = &quot;shinyExample&quot;, verbose=TRUE) library(shiny) runApp(&quot;shinyExample&quot;) Click here to go to the Shiny App 13.2.2 Exploring parameter fits graphically using shiny An RxODE object can be explored with rxShiny(obj). rxShiny() will also allow you to try new models to see how they behave. 13.3 Using RxODE with a pipeline 13.3.1 Setting up the RxODE model for the pipeline In this example we will show how to use RxODE in a simple pipeline. We can start with a model that can be used for the different simulation workflows that RxODE can handle: library(RxODE) Ribba2012 &lt;- RxODE({ k = 100 tkde = 0.24 eta.tkde = 0 kde ~ tkde*exp(eta.tkde) tkpq = 0.0295 eta.kpq = 0 kpq ~ tkpq * exp(eta.kpq) tkqpp = 0.0031 eta.kqpp = 0 kqpp ~ tkqpp * exp(eta.kqpp) tlambdap = 0.121 eta.lambdap = 0 lambdap ~ tlambdap*exp(eta.lambdap) tgamma = 0.729 eta.gamma = 0 gamma ~ tgamma*exp(eta.gamma) tdeltaqp = 0.00867 eta.deltaqp = 0 deltaqp ~ tdeltaqp*exp(eta.deltaqp) prop.err &lt;- 0 pstar &lt;- (pt+q+qp)*(1+prop.err) d/dt(c) = -kde * c d/dt(pt) = lambdap * pt *(1-pstar/k) + kqpp*qp - kpq*pt - gamma*c*kde*pt d/dt(q) = kpq*pt -gamma*c*kde*q d/dt(qp) = gamma*c*kde*q - kqpp*qp - deltaqp*qp #### initial conditions tpt0 = 7.13 eta.pt0 = 0 pt0 ~ tpt0*exp(eta.pt0) tq0 = 41.2 eta.q0 = 0 q0 ~ tq0*exp(eta.q0) pt(0) = pt0 q(0) = q0 }) This is a tumor growth model described in Ribba 2012. In this case, we compiled the model into an R object Ribba2012, though in an RxODE simulation pipeline, you do not have to assign the compiled model to any object, though I think it makes sense. 13.3.2 Simulating one event table Simulating a single event table is quite simple: You pipe the RxODE simulation object into an event table object by et(). When the events are completely specified, you simply solve the ODE system with rxSolve(). In this case you can pipe the output to plot() to conveniently view the results. Note for the plot we are only selecting the selecting following: pt (Proliferative Tissue), q (quiescent tissue) qp (DNA-Damaged quiescent tissue) and pstar (total tumor tissue) Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve() %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 13.3.3 Simulating multiple subjects from a single event table 13.3.3.1 Simulating with between subject variability The next sort of simulation that may be useful is simulating multiple patients with the same treatments. In this case, we will use the omega matrix specified by the paper: #### Add CVs from paper for individual simulation #### Uses exact formula: lognCv = function(x){log((x/100)^2+1)} library(lotri) #### Now create omega matrix #### I&#39;m using lotri to quickly specify names/diagonals omega &lt;- lotri(eta.pt0 ~ lognCv(94), eta.q0 ~ lognCv(54), eta.lambdap ~ lognCv(72), eta.kqp ~ lognCv(76), eta.qpp ~ lognCv(97), eta.deltaqp ~ lognCv(115), eta.kde ~ lognCv(70)) omega #&gt; eta.pt0 eta.q0 eta.lambdap eta.kqp eta.qpp eta.deltaqp #&gt; eta.pt0 0.6331848 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.q0 0.0000000 0.2558818 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.lambdap 0.0000000 0.0000000 0.4176571 0.0000000 0.0000000 0.0000000 #&gt; eta.kqp 0.0000000 0.0000000 0.0000000 0.4559047 0.0000000 0.0000000 #&gt; eta.qpp 0.0000000 0.0000000 0.0000000 0.0000000 0.6631518 0.0000000 #&gt; eta.deltaqp 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.8426442 #&gt; eta.kde 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.kde #&gt; eta.pt0 0.0000000 #&gt; eta.q0 0.0000000 #&gt; eta.lambdap 0.0000000 #&gt; eta.kqp 0.0000000 #&gt; eta.qpp 0.0000000 #&gt; eta.deltaqp 0.0000000 #&gt; eta.kde 0.3987761 With this information, it is easy to simulate 3 subjects from the model-based parameters: set.seed(1089) Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, omega=omega) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest Note there are two different things that were added to this simulation: - nSub to specify how many subjects are in the model - omega to specify the between subject variability. 13.3.3.2 Simulation with unexplained variability You can even add unexplained variability quite easily: Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, omega=omega, sigma=lotri(prop.err ~ 0.05^2)) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest In this case we only added the sigma matrix to have unexplained variability on the pstar or total tumor tissue. You can even simulate with uncertainty in the theta omega and sigma values if you wish. 13.3.3.3 Simulation with uncertainty in all the parameters (by matrices) If we assume these parameters came from 95 subjects with 8 observations apiece, the degrees of freedom for the omega matrix would be 95, and the degrees of freedom of the sigma matrix would be 95*8=760 because 95 items informed the omega matrix, and 760 items informed the sigma matrix. Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, nStud=3, omega=omega, sigma=lotri(prop.err ~ 0.05^2), dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest Often in simulations we have a full covariance matrix for the fixed effect parameters. In this case, we do not have the matrix, but it could be specified by thetaMat. While we do not have a full covariance matrix, we can have information about the diagonal elements of the covariance matrix from the model paper. These can be converted as follows: rseVar &lt;- function(est, rse){ return(est*rse/100)^2 } thetaMat &lt;- lotri(tpt0 ~ rseVar(7.13,25), tq0 ~ rseVar(41.2,7), tlambdap ~ rseVar(0.121, 16), tkqpp ~ rseVar(0.0031, 35), tdeltaqp ~ rseVar(0.00867, 21), tgamma ~ rseVar(0.729, 37), tkde ~ rseVar(0.24, 33) ); thetaMat #&gt; tpt0 tq0 tlambdap tkqpp tdeltaqp tgamma tkde #&gt; tpt0 1.7825 0.000 0.00000 0.000000 0.0000000 0.00000 0.0000 #&gt; tq0 0.0000 2.884 0.00000 0.000000 0.0000000 0.00000 0.0000 #&gt; tlambdap 0.0000 0.000 0.01936 0.000000 0.0000000 0.00000 0.0000 #&gt; tkqpp 0.0000 0.000 0.00000 0.001085 0.0000000 0.00000 0.0000 #&gt; tdeltaqp 0.0000 0.000 0.00000 0.000000 0.0018207 0.00000 0.0000 #&gt; tgamma 0.0000 0.000 0.00000 0.000000 0.0000000 0.26973 0.0000 #&gt; tkde 0.0000 0.000 0.00000 0.000000 0.0000000 0.00000 0.0792 Now we have a thetaMat to represent the uncertainty in the theta matrix, as well as the other pieces in the simulation. Typically you can put this information into your simulation with the thetaMat matrix. With such large variability in theta it is easy to sample a negative rate constant, which does not make sense. For example: Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=2, nStud=2, omega=omega, sigma=lotri(prop.err ~ 0.05^2), thetaMat=thetaMat, dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest #&gt; unhandled error message: EE:[lsoda] 70000 steps taken before reaching tout #&gt; @(lsoda.c:750 #&gt; Warning message: #&gt; In rxSolve_(object, .ctl, .nms, .xtra, params, events, inits, setupOnly = .setupOnly) : #&gt; Some ID(s) could not solve the ODEs correctly; These values are replaced with NA. To correct these problems you simply need to use a truncated multivariate normal and specify the reasonable ranges for the parameters. For theta this is specified by thetaLower and thetaUpper. Similar parameters are there for the other matrices: omegaLower, omegaUpper, sigmaLower and sigmaUpper. These may be named vectors, one numeric value, or a numeric vector matching the number of parameters specified in the thetaMat matrix. In this case the simulation simply has to be modified to have thetaLower=0 to make sure all rates are positive: Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=2, nStud=2, omega=omega, sigma=lotri(prop.err ~ 0.05^2), thetaMat=thetaMat, thetaLower=0, # Make sure the rates are reasonable dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 13.3.4 Summarizing the simulation output While it is easy to use dplyr and data.table to perform your own summary of simulations, RxODE also provides this ability by the confint function. #### This takes a little more time; Most of the time is the summary #### time. sim0 &lt;- Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=10, nStud=10, omega=omega, sigma=lotri(prop.err ~ 0.05^2), thetaMat=thetaMat, thetaLower=0, # Make sure the rates are reasonable dfSub=760, dfObs=95) %&gt;% # Solve the simulation confint(c(&quot;pt&quot;,&quot;q&quot;,&quot;qp&quot;,&quot;pstar&quot;),level=0.90); # Create Simulation intervals sim0 %&gt;% plot() # Plot the simulation intervals 13.3.4.1 Simulating from a data-frame of parameters While the simulation from matrices can be very useful and a fast way to simulate information, sometimes you may want to simulate more complex scenarios. For instance, there may be some reason to believe that tkde needs to be above tlambdap, therefore these need to be simulated more carefully. You can generate the data frame in whatever way you want. The internal method of simulating the new parameters is exported too. library(dplyr) pars &lt;- rxInits(Ribba2012); pars &lt;- pars[regexpr(&quot;(prop|eta)&quot;,names(pars)) == -1] print(pars) #&gt; k tkde tkpq tkqpp tlambdap tgamma tdeltaqp tpt0 #&gt; 1.00e+02 2.40e-01 2.95e-02 3.10e-03 1.21e-01 7.29e-01 8.67e-03 7.13e+00 #&gt; tq0 #&gt; 4.12e+01 #### This is the exported method for simulation of Theta/Omega internally in RxODE df &lt;- rxSimThetaOmega(params=pars, omega=omega,dfSub=760, thetaMat=thetaMat, thetaLower=0, nSub=60,nStud=60) %&gt;% filter(tkde &gt; tlambdap) %&gt;% as.tbl() #### You could also simulate more and bind them together to a data frame. print(df) #&gt; # A tibble: 2,340 x 16 #&gt; k tkde tkpq tkqpp tlambdap tgamma tdeltaqp tpt0 tq0 eta.pt0 eta.q0 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 0.559 0.136 #&gt; 2 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 0.0465 -0.581 #&gt; 3 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 -0.188 -0.180 #&gt; 4 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 0.321 0.614 #&gt; 5 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 0.0656 -0.232 #&gt; 6 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 0.0194 0.517 #&gt; 7 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 -0.218 0.260 #&gt; 8 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 -0.258 -0.761 #&gt; 9 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 -1.28 -1.34 #&gt; 10 100 2.83 0.0295 0.239 0.683 0.861 1.25 7.67 42.0 -0.495 0.161 #&gt; # ... with 2,330 more rows, and 5 more variables: eta.lambdap &lt;dbl&gt;, #&gt; # eta.kqp &lt;dbl&gt;, eta.qpp &lt;dbl&gt;, eta.deltaqp &lt;dbl&gt;, eta.kde &lt;dbl&gt; #### Quick check to make sure that all the parameters are OK. all(df$tkde&gt;df$tlambdap) #&gt; [1] TRUE sim1 &lt;- Ribba2012 %&gt;% # Use RxODE et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(df) #### Note this information looses information about which ID is in a #### &quot;study&quot;, so it summarizes the confidence intervals by dividing the #### subjects into sqrt(#subjects) subjects and then summarizes the #### confidence intervals sim2 &lt;- sim1 %&gt;% confint(c(&quot;pt&quot;,&quot;q&quot;,&quot;qp&quot;,&quot;pstar&quot;),level=0.90); # Create Simulation intervals save(sim2, file = file.path(system.file(package = &quot;RxODE&quot;), &quot;pipeline-sim2.rds&quot;), version = 2) sim2 %&gt;% plot() 13.4 Speeding up RxODE 13.4.1 Increasing RxODE speed by multi-subject parallel solving RxODE originally developed as an ODE solver that allowed an ODE solve for a single subject. This flexibility is still supported. The original code from the RxODE tutorial is below: library(RxODE) library(microbenchmark) library(ggplot2) mod1 &lt;- RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) = -KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }) #### Create an event table ev &lt;- et() %&gt;% et(amt=10000, addl=9,ii=12) %&gt;% et(time=120, amt=20000, addl=4, ii=24) %&gt;% et(0:240) ## Add Sampling nsub &lt;- 100 # 100 sub-problems sigma &lt;- matrix(c(0.09,0.08,0.08,0.25),2,2) # IIV covariance matrix mv &lt;- rxRmvn(n=nsub, rep(0,2), sigma) # Sample from covariance matrix CL &lt;- 7*exp(mv[,1]) V2 &lt;- 40*exp(mv[,2]) params.all &lt;- cbind(KA=0.3, CL=CL, V2=V2, Q=10, V3=300, Kin=0.2, Kout=0.2, EC50=8) 13.4.1.1 For Loop The slowest way to code this is to use a for loop. In this example we will enclose it in a function to compare timing. runFor &lt;- function(){ res &lt;- NULL for (i in 1:nsub) { params &lt;- params.all[i,] x &lt;- mod1$solve(params, ev, cacheEvent=FALSE) ##Store results for effect compartment res &lt;- cbind(res, x[, &quot;eff&quot;]) } return(res) } 13.4.1.2 Running with apply In general for R, the apply types of functions perform better than a for loop, so the tutorial also suggests this speed enhancement runSapply &lt;- function(){ res &lt;- apply(params.all, 1, function(theta) mod1$run(theta, ev, cacheEvent=FALSE)[, &quot;eff&quot;]) } 13.4.1.3 Run using a single-threaded solve You can also have RxODE solve all the subject simultaneously without collecting the results in R, using a single threaded solve. The data output is slightly different here, but still gives the same information: runSingleThread &lt;- function(){ solve(mod1, params.all, ev, cores=1, cacheEvent=FALSE)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } 13.4.1.4 Run a 2 threaded solve RxODE supports multi-threaded solves, so another option is to have 2 threads (called cores in the solve options, you can see the options in rxControl() or rxSolve()). run2Thread &lt;- function(){ solve(mod1, params.all, ev, cores=2, cacheEvent=FALSE)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } 13.4.1.5 Compare the times between all the methods Now the moment of truth, the timings: bench &lt;- microbenchmark(runFor(), runSapply(), runSingleThread(),run2Thread()) print(bench) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max #&gt; runFor() 149.52081 171.27062 192.90942 190.02686 211.04242 349.87083 #&gt; runSapply() 148.46279 170.85325 192.90897 203.24540 209.75845 343.35761 #&gt; runSingleThread() 21.79790 25.92407 27.43815 26.63215 29.40284 34.89256 #&gt; run2Thread() 13.99345 15.03455 16.58391 15.26519 15.79007 32.19146 #&gt; neval #&gt; 100 #&gt; 100 #&gt; 100 #&gt; 100 autoplot(bench) It is clear that the largest jump in performance when using the solve method and providing all the parameters to RxODE to solve without looping over each subject with either a for or a sapply. The number of cores/threads applied to the solve also plays a role in the solving. We can explore the number of threads further with the following code: runThread &lt;- function(n){ solve(mod1, params.all, ev, cores=n, cacheEvent=FALSE)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } bench &lt;- eval(parse(text=sprintf(&quot;microbenchmark(%s)&quot;, paste(paste0(&quot;runThread(&quot;, seq(1, 2 * rxCores()),&quot;)&quot;), collapse=&quot;,&quot;)))) print(bench) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; runThread(1) 21.50871 23.13192 39.27643 25.81496 27.56073 1021.6726 100 #&gt; runThread(2) 13.14395 14.72681 44.98351 16.65848 29.15620 814.2002 100 #&gt; runThread(3) 11.38847 12.71787 48.01460 19.05276 21.92472 446.1831 100 #&gt; runThread(4) 14.65711 16.10307 54.13006 16.70819 20.03974 411.9033 100 #&gt; runThread(5) 12.95509 14.35766 57.15010 15.32234 20.12732 433.2323 100 #&gt; runThread(6) 12.62878 13.48153 62.76636 13.98110 22.89068 475.2186 100 #&gt; runThread(7) 11.52002 12.94464 70.78100 14.47153 132.10935 522.5479 100 #&gt; runThread(8) 21.04313 32.49421 92.58168 106.31139 131.07819 370.4774 100 autoplot(bench) There can be a suite spot in speed vs number or cores. The system type (mac, linux, windows and/or processor), complexity of the ODE solving and the number of subjects may affect this arbitrary number of threads. 4 threads is a good number to use without any prior knowledge because most systems these days have at least 4 threads (or 2 processors with 4 threads). 13.4.2 A real life example Before some of the parallel solving was implemented, the fastest way to run RxODE was with lapply. This is how Rik Schoemaker created the data-set for nlmixr comparisons, but reduced to run faster automatic building of the pkgdown website. library(RxODE) library(data.table) #Define the RxODE model ode1 &lt;- &quot; d/dt(abs) = -KA*abs; d/dt(centr) = KA*abs-(CL/V)*centr; C2=centr/V; &quot; #Create the RxODE simulation object mod1 &lt;- RxODE(model = ode1) #Population parameter values on log-scale paramsl &lt;- c(CL = log(4), V = log(70), KA = log(1)) #make 10,000 subjects to sample from: nsubg &lt;- 300 # subjects per dose doses &lt;- c(10, 30, 60, 120) nsub &lt;- nsubg * length(doses) #IIV of 30% for each parameter omega &lt;- diag(c(0.09, 0.09, 0.09))# IIV covariance matrix sigma &lt;- 0.2 #Sample from the multivariate normal set.seed(98176247) library(MASS) mv &lt;- mvrnorm(nsub, rep(0, dim(omega)[1]), omega) # Sample from covariance matrix #Combine population parameters with IIV params.all &lt;- data.table( &quot;ID&quot; = seq(1:nsub), &quot;CL&quot; = exp(paramsl[&#39;CL&#39;] + mv[, 1]), &quot;V&quot; = exp(paramsl[&#39;V&#39;] + mv[, 2]), &quot;KA&quot; = exp(paramsl[&#39;KA&#39;] + mv[, 3]) ) #set the doses (looping through the 4 doses) params.all[, AMT := rep(100 * doses,nsubg)] Startlapply &lt;- Sys.time() #Run the simulations using lapply for speed s = lapply(1:nsub, function(i) { #selects the parameters associated with the subject to be simulated params &lt;- params.all[i] #creates an eventTable with 7 doses every 24 hours ev &lt;- eventTable() ev$add.dosing( dose = params$AMT, nbr.doses = 1, dosing.to = 1, rate = NULL, start.time = 0 ) #generates 4 random samples in a 24 hour period ev$add.sampling(c(0, sort(round(sample(runif(600, 0, 1440), 4) / 60, 2)))) #runs the RxODE simulation x &lt;- as.data.table(mod1$run(params, ev)) #merges the parameters and ID number to the simulation output x[, names(params) := params] }) #runs the entire sequence of 100 subjects and binds the results to the object res res = as.data.table(do.call(&quot;rbind&quot;, s)) Stoplapply &lt;- Sys.time() print(Stoplapply - Startlapply) #&gt; Time difference of 6.183588 secs By applying some of the new parallel solving concepts you can simply run the same simulation both with less code and faster: rx &lt;- RxODE({ CL = log(4) V = log(70) KA = log(1) CL = exp(CL + eta.CL) V = exp(V + eta.V) KA = exp(KA + eta.KA) d/dt(abs) = -KA*abs; d/dt(centr) = KA*abs-(CL/V)*centr; C2=centr/V; }) omega &lt;- lotri(eta.CL ~ 0.09, eta.V ~ 0.09, eta.KA ~ 0.09) doses &lt;- c(10, 30, 60, 120) startParallel &lt;- Sys.time() ev &lt;- do.call(&quot;rbind&quot;, lapply(seq_along(doses), function(i){ et() %&gt;% et(amt=doses[i]) %&gt;% # Add single dose et(0) %&gt;% # Add 0 observation #### Generate 4 samples in 24 hour period et(lapply(1:4, function(...){c(0, 24)})) %&gt;% et(id=seq(1, nsubg) + (i - 1) * nsubg) %&gt;% #### Convert to data frame to skip sorting the data #### When binding the data together as.data.frame })) #### To better compare, use the same output, that is data.table res &lt;- rxSolve(rx, ev, omega=omega, returnType=&quot;data.table&quot;) endParallel &lt;- Sys.time() print(endParallel - startParallel) #&gt; Time difference of 0.06572223 secs You can see a striking time difference between the two methods; A few things to keep in mind: RxODE use the thread-safe sitmo threefry routines for simulation of eta values. Therefore the results are expected to be different (also the random samples are taken in a different order which would be different) This prior simulation was run in R 3.5, which has a different random number generator so the results in this simulation will be different from the actual nlmixr comparison when using the slower simulation. This speed comparison used data.table. RxODE uses data.table internally (when available) try to speed up sorting, so this would be different than installations where data.table is not installed. You can force RxODE to use order() when sorting by using forderForceBase(TRUE). In this case there is little difference between the two, though in other examples data.table’s presence leads to a speed increase (and less likely it could lead to a slowdown). 13.4.2.1 Want more ways to run multi-subject simulations The version since the tutorial has even more ways to run multi-subject simulations, including adding variability in sampling and dosing times with et() (see RxODE events for more information), ability to supply both an omega and sigma matrix as well as adding as a thetaMat to R to simulate with uncertainty in the omega, sigma and theta matrices; see RxODE simulation vignette. 13.5 Integrating RxODE models in your package 13.5.1 Using Pre-compiled models in your packages If you have a package and would like to include pre-compiled RxODE models in your package it is easy to create the package. You simple make the package with the rxPkg() command. library(RxODE); #### Now Create a model idr &lt;- RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) #### You can specify as many models as you want to add rxPkg(idr, package=&quot;myPackage&quot;); ## Add the idr model to your package This will: Add the model to your package; You can use the package data as idr once the package loads Add the right package requirements to the DESCRIPTION file. You will want to update this to describe the package and modify authors, license etc. Create skeleton model documentation files you can add to for your package documentation. In this case it would be the file idr-doc.R in your R directory Create a configure and configure.win script that removes and regenerates the src directory based on whatever version of RxODE this is compiled against. This should be modified if you plan to have your own compiled code, though this is not suggested. You can write your own R code in your package that interacts with the RxODE object so you can distribute shiny apps and similar things in the package context. Once this is present you can add more models to your package by rxUse(). Simply compile the RxODE model in your package then add the model with rxUse() rxUse(model) Now both model and idr are in the model library. This will also create model-doc.R in your R directory so you can document this model. You can then use devtools methods to install/test your model devtools::load_all() # Load all the functions in the package devtools::document() # Create package documentation devtools::install() # Install package devtools::check() # Check the package devtools::build() # build the package so you can submit it to places like CRAN 13.5.2 Using Models in a already present package To illustrate, lets start with a blank package library(RxODE) library(usethis) pkgPath &lt;- file.path(rxTempDir(),&quot;MyRxModel&quot;) create_package(pkgPath); use_gpl3_license(&quot;Matt&quot;) use_package(&quot;RxODE&quot;, &quot;LinkingTo&quot;) use_package(&quot;RxODE&quot;, &quot;Depends&quot;) ## library(RxODE) on load; Can use imports instead. use_roxygen_md() ##use_readme_md() library(RxODE); #### Now Create a model idr &lt;- RxODE({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }); rxUse(idr); ## Add the idr model to your package rxUse(); # Update the compiled RxODE sources for all of your packages The rxUse() will: - Create RxODE sources and move them into the package’s src/ directory. If there is only R source in the package, it will also finish off the directory with an library-init.c which registers all the RxODE models in the package for use in R. - Create stub R documentation for each of the models your are including in your package. You will be able to see the R documentation when loading your package by the standard ? interface. You will still need to: - Export at least one function. If you do not have a function that you wish to export, you can add a re-export of RxODE using roxygen as follows: ##&#39; @importFrom RxODE RxODE ##&#39; @export RxODE::RxODE If you want to use Suggests instead of Depends in your package, you way want to export all of RxODE’s normal routines ##&#39; @importFrom RxODE RxODE ##&#39; @export RxODE::RxODE ##&#39; @importFrom RxODE et ##&#39; @export RxODE::et ##&#39; @importFrom RxODE etRep ##&#39; @export RxODE::etRep ##&#39; @importFrom RxODE etSeq ##&#39; @export RxODE::etSeq ##&#39; @importFrom RxODE as.et ##&#39; @export RxODE::as.et ##&#39; @importFrom RxODE eventTable ##&#39; @export RxODE::eventTable ##&#39; @importFrom RxODE add.dosing ##&#39; @export RxODE::add.dosing ##&#39; @importFrom RxODE add.sampling ##&#39; @export RxODE::add.sampling ##&#39; @importFrom RxODE rxSolve ##&#39; @export RxODE::rxSolve ##&#39; @importFrom RxODE rxControl ##&#39; @export RxODE::rxControl ##&#39; @importFrom RxODE rxClean ##&#39; @export RxODE::rxClean ##&#39; @importFrom RxODE rxUse ##&#39; @export RxODE::rxUse ##&#39; @importFrom RxODE rxShiny ##&#39; @export RxODE::rxShiny ##&#39; @importFrom RxODE genShinyApp.template ##&#39; @export RxODE::genShinyApp.template ##&#39; @importFrom RxODE cvPost ##&#39; @export RxODE::cvPost ### This is actually from `magrittr` but allows less imports ##&#39; @importFrom RxODE %&gt;% ##&#39; @export RxODE::`%&gt;%` You also need to instruct R to load the model library models included in the model’s dll. This is done by: ### In this case `rxModels` is the package name ##&#39; @useDynLib rxModels, .registration=TRUE If this is a R package with RxODE models and you do not intend to add any other compiled sources (recommended), you can add the following configure scripts #!/bin/sh ### This should be used for both configure and configure.win echo &quot;unlink(&#39;src&#39;, recursive=TRUE);RxODE::rxUse()&quot; &gt; build.R ${R_HOME}/bin/Rscript build.R rm build.R Depending on the check you may need a dummy autoconf script, #### dummy autoconf script #### It is saved to configure.ac If you want to integrate with other sources in your Rcpp or C/Fortan based packages, you need to include rxModels-compiled.h and: - Add the define macro compiledModelCall to the list of registered .Call functions. - Register C interface to allow model solving by R_init0_rxModels_RxODE_models() (again rxModels would be replaced by your package name). Once this is complete, you can compile/document by the standard methods: devtools::load_all() devtools::document() devtools::install() If you load the package with a new version of RxODE, the models will be recompiled when they are used. However, if you want the models recompiled for the most recent version of RxODE, you simply need to call rxUse() again in the project directory followed by the standard methods for install/create a package. devtools::load_all() devtools::document() devtools::install() Note you do not have to include the RxODE code required to generate the model to regenerate the RxODE c-code in the src directory. As with all RxODE objects, a summary will show one way to recreate the same model. An example of compiled models package can be found in the rxModels repository. 13.6 Stiff ODEs with Jacobian Specification 13.6.0.1 Stiff ODEs with Jacobian Specification Occasionally, you may come across a stiff differential equation, that is a differential equation that is numerically unstable and small variations in parameters cause different solutions to the ODEs. One way to tackle this is to choose a stiff-solver, or hybrid stiff solver (like the default LSODA). Typically this is enough. However exact Jacobian solutions may increase the stability of the ODE. (Note the Jacobian is the derivative of the ODE specification with respect to each variable). In RxODE you can specify the Jacobian with the df(state)/dy(variable)= statement. A classic ODE that has stiff properties under various conditions is the Van der Pol differential equations. In RxODE these can be specified by the following: library(RxODE) Vtpol2 &lt;- RxODE({ d/dt(y) = dy d/dt(dy) = mu*(1-y^2)*dy - y ##### Jacobian df(y)/dy(dy) = 1 df(dy)/dy(y) = -2*dy*mu*y - 1 df(dy)/dy(dy) = mu*(1-y^2) ##### Initial conditions y(0) = 2 dy(0) = 0 ##### mu mu = 1 ## nonstiff; 10 moderately stiff; 1000 stiff }) et &lt;- eventTable(); et$add.sampling(seq(0, 10, length.out=200)); et$add.dosing(20, start.time=0); s1 &lt;- Vtpol2 %&gt;% solve(et, method=&quot;lsoda&quot;) print(s1) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; mu #&gt; 1 #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; y dy #&gt; 2 0 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 200 x 3 #&gt; time y dy #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 22 0 #&gt; 2 0.0503 22.0 -0.0456 #&gt; 3 0.101 22.0 -0.0456 #&gt; 4 0.151 22.0 -0.0456 #&gt; 5 0.201 22.0 -0.0456 #&gt; 6 0.251 22.0 -0.0456 #&gt; # ... with 194 more rows #&gt; ________________________________________________________________________________ While this is not stiff at mu=1, mu=1000 is a stiff system s2 &lt;- Vtpol2 %&gt;% solve(c(mu=1000), et) print(s2) #&gt; ______________________________ Solved RxODE object _____________________________ #&gt; -- Parameters ($params): ------------------------------------------------------- #&gt; mu #&gt; 1000 #&gt; -- Initial Conditions ($inits): ------------------------------------------------ #&gt; y dy #&gt; 2 0 #&gt; -- First part of data (object): ------------------------------------------------ #&gt; # A tibble: 200 x 3 #&gt; time y dy #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 22 0 #&gt; 2 0.0503 22.0 -0.0000455 #&gt; 3 0.101 22.0 -0.0000455 #&gt; 4 0.151 22.0 -0.0000455 #&gt; 5 0.201 22.0 -0.0000455 #&gt; 6 0.251 22.0 -0.0000455 #&gt; # ... with 194 more rows #&gt; ________________________________________________________________________________ While this is easy enough to do, it is a bit tedious. If you have RxODE setup appropriately, that is you have: Python installed in your system sympy installed in your system SnakeCharmR installed in R You can use the computer algebra system sympy to calculate the Jacobian automatically. This is done by the RxODE option calcJac option: Vtpol &lt;- RxODE({ d/dt(y) = dy d/dt(dy) = mu*(1-y^2)*dy - y ##### Initial conditions y(0) = 2 dy(0) = 0 ##### mu mu = 1 ## nonstiff; 10 moderately stiff; 1000 stiff }, calcJac=TRUE) To see the generated model, you can use rxCat(): &gt; rxCat(Vtpol) d/dt(y)=dy; d/dt(dy)=mu*(1-y^2)*dy-y; y(0)=2; dy(0)=0; mu=1; df(y)/dy(y)=0; df(dy)/dy(y)=-2*dy*mu*y-1; df(y)/dy(dy)=1; df(dy)/dy(dy)=mu*(-Rx_pow_di(y,2)+1); "]]
